/*
Copyright 2016 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package generators

import (
	"fmt"
	"io"
	"strings"
	"unicode"

	"k8s.io/gengo/args"
	"k8s.io/gengo/generator"
	"k8s.io/gengo/namer"
	"k8s.io/gengo/types"

	"github.com/golang/glog"
)

// CustomArgs is used tby the go2idl framework to pass args specific to this
// generator.
type CustomArgs struct {
	BoundingDirs []string // Only deal with types rooted under these dirs.
}

// This is the comment tag that carries parameters for deep-copy generation.
const tagName = "k8s:json-gen"

// Known values for the comment tag.
const tagValuePackage = "package"

// tagValue holds parameters from a tagName tag.
type tagValue struct {
	value string
}

func extractTag(comments []string) *tagValue {
	tagVals := types.ExtractCommentTags("+", comments)[tagName]
	if tagVals == nil {
		// No match for the tag.
		return nil
	}
	// If there are multiple values, abort.
	if len(tagVals) > 1 {
		glog.Fatalf("Found %d %s tags: %q", len(tagVals), tagName, tagVals)
	}

	// If we got here we are returning something.
	tag := &tagValue{}

	// Get the primary value.
	parts := strings.Split(tagVals[0], ",")
	if len(parts) >= 1 {
		tag.value = parts[0]
	}

	// Parse extra arguments.
	parts = parts[1:]
	for i := range parts {
		kv := strings.SplitN(parts[i], "=", 2)
		k := kv[0]
		v := ""
		if len(kv) == 2 {
			v = kv[1]
		}
		switch k {
		default:
			_ = k
			_ = v
			glog.Fatalf("Unsupported %s param: %q", tagName, parts[i])
		}
	}
	return tag
}

// FIXME: examine what we want to name things
func jsonNamer() *namer.NameStrategy {
	return &namer.NameStrategy{
		Join: func(pre string, in []string, post string) string {
			return strings.Join(in, "_")
		},
		PrependPackageNames: 1,
	}
}

// NameSystems returns the name system used by the generators in this package.
func NameSystems() namer.NameSystems {
	return namer.NameSystems{
		"public": jsonNamer(),
		"raw":    namer.NewRawNamer("", nil),
	}
}

// DefaultNameSystem returns the default name system for ordering the types to be
// processed by the generators in this package.
func DefaultNameSystem() string {
	return "public"
}

func Packages(context *generator.Context, arguments *args.GeneratorArgs) generator.Packages {
	boilerplate, err := arguments.LoadGoBoilerplate()
	if err != nil {
		glog.Fatalf("Failed loading boilerplate: %v", err)
	}

	header := append([]byte(fmt.Sprintf("// +build !%s\n\n", arguments.GeneratedBuildTag)), boilerplate...)
	header = append(header, []byte(
		`
// This file was autogenerated by json-gen. Do not edit it manually!

`)...)

	boundingDirs := []string{}
	if customArgs, ok := arguments.CustomArgs.(*CustomArgs); ok {
		for i := range customArgs.BoundingDirs {
			// Strip any trailing slashes - they are not exactly "correct" but
			// this is friendlier.
			boundingDirs = append(boundingDirs, strings.TrimRight(customArgs.BoundingDirs[i], "/"))
		}
	}

	// Results accumulator.
	packages := generator.Packages{}

	// De-dup inputs.
	inputs := map[string]bool{}
	for _, i := range context.Inputs {
		inputs[i] = true
	}

	for i := range inputs {
		glog.V(5).Infof("considering pkg %q", i)
		pkg := context.Universe[i]
		if pkg == nil {
			glog.V(5).Infof("package %q is nil in context.Universe: skipping", i)
			// If the input had no Go files, for example.
			continue
		}

		// Find the tags, if present.
		ptag := extractTag(pkg.Comments)
		ptagValue := ""
		if ptag != nil {
			ptagValue = ptag.value
			if ptagValue != tagValuePackage {
				glog.Fatalf("Package %v: unsupported %s value: %q", i, tagName, ptagValue)
			}
			glog.V(5).Infof("  tag.value: %q", ptagValue)
		} else {
			glog.V(5).Infof("  no tag")
		}

		// If the pkg-scoped tag says to generate, we can skip scanning types.
		pkgNeedsGeneration := (ptagValue == tagValuePackage)
		if !pkgNeedsGeneration {
			// If the pkg-scoped tag did not exist, scan all types for one that
			// explicitly wants generation.
			for _, t := range pkg.Types {
				glog.V(5).Infof("  considering type %q", t.Name.String())
				ttag := extractTag(t.CommentLines)
				if ttag != nil && ttag.value == "true" {
					glog.V(5).Infof("    tag=true")
					pkgNeedsGeneration = true
					break
				}
			}
		}

		if pkgNeedsGeneration {
			packages = append(packages,
				&generator.DefaultPackage{
					PackageName: pkg.Name,
					PackagePath: pkg.Path,
					HeaderText:  header,
					GeneratorFunc: func(c *generator.Context) (generators []generator.Generator) {
						return []generator.Generator{
							newGenerator(
								arguments.OutputFileBaseName, pkg.Path, //FIXME: use outputbase
								boundingDirs, (ptagValue == tagValuePackage)),
						}
					},
					FilterFunc: func(c *generator.Context, t *types.Type) bool {
						return t.Name.Package == pkg.Path
					},
				})
		}
	}
	return packages
}

// jsonGenerator produces a file with autogenerated deep-copy functions.
type jsonGenerator struct {
	generator.DefaultGen
	targetPackage  string
	boundingDirs   []string
	emitAllTypes   bool
	imports        namer.ImportTracker
	builtinsNeeded map[string]*types.Type
}

func newGenerator(sanitizedName string, targetPackage string, boundingDirs []string, emitAllTypes bool) generator.Generator {
	return &jsonGenerator{
		DefaultGen: generator.DefaultGen{
			OptionalName: sanitizedName,
		},
		targetPackage:  targetPackage,
		boundingDirs:   boundingDirs,
		emitAllTypes:   emitAllTypes,
		imports:        generator.NewImportTracker(),
		builtinsNeeded: map[string]*types.Type{},
	}
}

func (g *jsonGenerator) Namers(c *generator.Context) namer.NameSystems {
	// Have the raw namer for this file track what it imports.
	return namer.NameSystems{
		"raw": namer.NewRawNamer(g.targetPackage, g.imports),
		//FIXME
		//"dcFnName": &dcFnNamer{
		//	public:    deepCopyNamer(),
		//	tracker:   g.imports,
		//	myPackage: g.targetPackage,
		//},
	}
}

func (g *jsonGenerator) Filter(c *generator.Context, t *types.Type) bool {
	// Filter out types that are not being processed.
	if g.emitAllTypes {
		return true
	}
	if ttag := extractTag(t.CommentLines); ttag != nil && ttag.value == "true" {
		return true
	}
	return false
}

func (g *jsonGenerator) inBounds(t *types.Type) bool {
	// Only packages within the restricted range can be processed.
	if !isRootedUnder(t.Name.Package, g.boundingDirs) {
		return false
	}
	return true
}

func isRootedUnder(pkg string, roots []string) bool {
	// Add trailing / to avoid false matches, e.g. foo/bar vs foo/barn.  This
	// assumes that bounding dirs do not have trailing slashes.
	pkg = pkg + "/"
	for _, root := range roots {
		if strings.HasPrefix(string(pkg), string(root)+"/") {
			return true
		}
	}
	return false
}

var nameOfByteSlice = types.Name{Name: "[]byte"}
var nameOfError = types.Name{Name: "error"}

// hasMarshalMethod returns true if an appropriate MarshalJSON() method is
// defined for the given type.
func hasMarshalMethod(t *types.Type) bool {
	for mn, mt := range t.Methods {
		if mn != "MarshalJSON" {
			continue
		}
		if len(mt.Signature.Parameters) != 0 {
			return false
		}
		if len(mt.Signature.Results) != 2 ||
			mt.Signature.Results[0].Name != nameOfByteSlice ||
			mt.Signature.Results[1].Name != nameOfError {
			return false
		}
		return true
	}
	return false
}

func (g *jsonGenerator) isOtherPackage(importLine string) bool {
	if strings.HasSuffix(string(importLine), "\""+string(g.targetPackage)+"\"") {
		return false
	}
	return true
}

func (g *jsonGenerator) Imports(c *generator.Context) []string {
	importLines := []string{}
	for _, singleImport := range g.imports.ImportLines() {
		if g.isOtherPackage(singleImport) {
			importLines = append(importLines, singleImport)
		}
	}
	return importLines
}

func argsFromType(t *types.Type) generator.Args {
	return generator.Args{
		"type": t,
	}
}

/* FIXME:
type dcFnNamer struct {
	public    namer.Namer
	tracker   namer.ImportTracker
	myPackage string
}

func (n *dcFnNamer) Name(t *types.Type) string {
	pubName := n.public.Name(t)
	n.tracker.AddType(t)
	if t.Name.Package == n.myPackage {
		return "DeepCopy_" + pubName
	}
	return fmt.Sprintf("%s.DeepCopy_%s", n.tracker.LocalNameOf(t.Name.Package), pubName)
}
*/

func (g *jsonGenerator) Init(c *generator.Context, w io.Writer) error {
	sw := generator.NewSnippetWriter(w, c, "$", "$")
	sw.Do("func init() {\n", nil)
	sw.Do("}\n", nil)
	// TODO: move all these to a common json_runtime pkg, including all builtins
	sw.Do(`
		var trueBytes = []byte("true")
	    var falseBytes = []byte("false")
	    var nullBytes = []byte("null")
		`, nil)
	return sw.Error()
}

func (g *jsonGenerator) GenerateType(c *generator.Context, t *types.Type, w io.Writer) error {
	glog.V(5).Infof("generating for type %v", t)
	if !g.needsGeneration(t) {
		glog.V(5).Infof("type %v does not need generation", t)
		return nil
	}

	sw := generator.NewSnippetWriter(w, c, "$", "$")
	//FIXME: always take pointer?  benchmark  Maybe only for struct
	g.imports.Add("bytes")
	//FIXME: make private names once they are registered
	sw.Do("func Marshal_$.type|public$(obj $.type|raw$, buf *bytes.Buffer) error {\n", argsFromType(t))
	g.emitMarshalerFor(t, sw)
	sw.Do("\nreturn nil\n", nil)
	sw.Do("}\n\n", nil)
	return sw.Error()
}

func (g *jsonGenerator) needsGeneration(t *types.Type) bool {
	if t.Kind == types.DeclarationOf {
		return false
	}

	tag := extractTag(t.CommentLines)
	tv := ""
	if tag != nil {
		tv = tag.value
		if tv != "true" && tv != "false" {
			glog.Fatalf("Type %v: unsupported %s value: %q", t, tagName, tag.value)
		}
	}
	if g.emitAllTypes && tv == "false" {
		// The whole package is being generated, but this type has opted out.
		glog.V(5).Infof("not generating for type %v because type opted out", t)
		return false
	}
	if !g.emitAllTypes && tv != "true" {
		// The whole package is NOT being generated, and this type has NOT opted in.
		glog.V(5).Infof("not generating for type %v because type did not opt in", t)
		return false
	}
	return true
}

// emitMarshalerFor emits (via sw) a block of code which marshals an instance
// of t.  The emitted code will return if it hits an error.
func (g *jsonGenerator) emitMarshalerFor(t *types.Type, sw *generator.SnippetWriter) {
	// If the type implements Marshaler on its own, use that.
	if hasMarshalMethod(t) {
		sw.Do(`
			if b, err := obj.MarshalJSON(); err != nil {
				return err
			} else if _, err := buf.Write(b); err != nil {
				return err
			}
			`, nil)
		return
	}

	// Peel away a layer of alias.
	if t.Kind == types.Alias {
		t = t.Underlying
	}
	// Just call another function for simple cases.
	if t.Kind == types.Alias || t.Kind == types.Builtin {
		sw.Do(`
			if err := Marshal_$.type|public$($.type|public$(obj), buf); err != nil {
				return err
			}
			`, argsFromType(t))
		if t.Kind == types.Builtin {
			// We will emit common marshalers for builtins later.
			g.builtinsNeeded[t.String()] = t
		}
		return
	}

	var f func(*types.Type, *generator.SnippetWriter) error

	// Handle more complex cases.  Each of these functions will emit a block
	// of code to marshal the respective types.  The emitted code should return
	// if it hits an error, but NOT if it is successful.  This allows these
	// blocks to be used in multiple contexts, and the contexts will handle
	// successful returns.
	switch t.Kind {
	case types.Pointer:
		f = g.emitMarshalerForPointer
	case types.Struct:
		f = g.emitMarshalerForStruct
	case types.Slice:
		f = g.emitMarshalerForSlice
	case types.Map:
		f = g.emitMarshalerForMap
	default:
		panic("unsupported kind: " + string(t.Kind) + " for type " + string(t.String()))
	}
	if err := f(t, sw); err != nil {
		panic("can't emit marshaler for " + string(t.String()) + ": " + err.Error())
	}
}

func (g *jsonGenerator) emitMarshalerForPointer(t *types.Type, sw *generator.SnippetWriter) error {
	sw.Do(`
		if obj == nil {
	    	if _, err := buf.Write(nullBytes); err != nil {
				return err
			}
		} else {
			err := Marshal_$.type|public$(($.type|raw$)(*obj), buf)
		  	if err != nil {
		  		return err
		    }
		}
		`, argsFromType(t.Elem))
	return nil
}

type jsonTag struct {
	name      string
	omitempty bool
}

//FIXME: formatting output on emit
func (g *jsonGenerator) emitMarshalerForStruct(t *types.Type, sw *generator.SnippetWriter) error {
	if len(t.Members) == 0 {
		// at least do something with args to avoid "not used" errors
		sw.Do("_ = obj\n", nil)
	}

	sw.Do(`
		if _, err := buf.WriteString("{"); err != nil {
			return err
		}
		`, nil)
	for i, m := range t.Members {
		name := ""
		if m.Tags != "" {
			glog.V(3).Infof("found struct tags for %v.%s", t, m.Name)
			tag, err := parseTag(m.Tags)
			if err != nil {
				return fmt.Errorf("failed to parse struct tag for %s.%s: %v", t, m.Name, err)
			}
			name = tag.name
			if name == "-" {
				// Skip this field
				continue
			}
		}
		if name == "" {
			name = m.Name
		}
		sw.Do("// "+m.Name+"\n", nil)
		if m.Embedded {
			//FIXME: embedded output includes wrapping "{}"
			//FIXME: embedded primitives use typename
			//FIXME: embedded empty structs
			g.emitMarshalerForEmbedded(m.Type, sw, i > 0)
		} else {
			if i > 0 {
				//FIXME: convert back to `sw.Do`?
				//FIXME: register and provide a public func
				sw.Do(`
				if _, err := buf.WriteString(","); err != nil {
					return err
				}
				`, nil)
			}
			sw.Do(`
			if _, err := buf.WriteString("\"`+name+`\": "); err != nil {
				return err
			} else {
				obj := obj.`+m.Name+`
			`, nil)
			g.emitMarshalerFor(m.Type, sw)
			sw.Do(`
			}
			`, nil)
		}
	}
	sw.Do(`
		if _, err := buf.WriteString("}"); err != nil {
			return err
		}`, nil)
	return nil
}

type kv struct {
	key string
	val string
}

const (
	stateKey = iota
	stateColon
	stateValue
	stateEscape
)

func parseTag(str string) (jsonTag, error) {
	tags := []kv{}

	key := ""
	val := ""
	state := stateKey
	pos := 0
	for _, r := range str {
		switch state {
		case stateKey:
			//FIXME: look up spec for tag names
			if unicode.IsLetter(r) || unicode.IsNumber(r) || r == '_' || r == '.' {
				key += string(r)
			} else if r == ':' {
				state = stateColon
			} else {
				return jsonTag{}, fmt.Errorf("unexpected character[%d] '%v' parsing tag name", pos, r)
			}
		case stateColon:
			if r == '"' {
				state = stateValue
			} else {
				return jsonTag{}, fmt.Errorf("unexpected character[%d] '%v' parsing tag value", pos, r)
			}
		case stateValue:
			if r == '\\' {
				state = stateEscape
			} else if r == '"' {
				glog.V(5).Infof("parsed tag %s:%q", key, val)
				tags = append(tags, kv{key: key, val: val})
				state = stateKey
			} else {
				val += string(r)
			}
		case stateEscape:
			//FIXME: look up what escapes are supported
			val += string(r)
		}
		pos++
	}

	result := jsonTag{}
	for _, tag := range tags {
		if tag.key != "json" {
			continue
		}
		parts := strings.Split(tag.val, ",")
		if len(parts) >= 1 {
			result.name = parts[0]
		}
		for i := 1; i < len(parts); i++ {
			if parts[i] == "omitempty" {
				result.omitempty = true
			} else {
				return jsonTag{}, fmt.Errorf("unexpected tag-item %q in json tag", parts[i])
			}
		}
	}
	return result, nil
}

func (g *jsonGenerator) emitMarshalerForSlice(t *types.Type, sw *generator.SnippetWriter) error {
	//FIXME: here and other similar - pass obj to func?
	//FIXME: maybe emit Marshal_string() into a common pkg?
	sw.Do(`
		if _, err := buf.WriteString("["); err != nil {
			return err
		}
		for i := range obj {
			obj := obj[i]
			if i > 0 {
				if _, err := buf.WriteString(","); err != nil {
					return err
				}
			}
		`, nil)
	g.emitMarshalerFor(t.Elem, sw)
	sw.Do(`
		}
	    if _, err := buf.WriteString("]"); err != nil {
			return err
		}
		`, nil)
	return nil
}

func (g *jsonGenerator) emitMarshalerForMap(t *types.Type, sw *generator.SnippetWriter) error {
	tKey := t.Key
	// Peel away layers of alias.
	for tKey.Kind == types.Alias {
		tKey = tKey.Underlying
	}
	// Map keys must be strings.
	if tKey != types.String {
		return fmt.Errorf("map key for type must be string (%v)", tKey)
	}

	g.imports.Add("sort")
	sw.Do(`
		if _, err := buf.WriteString("{"); err != nil {
			return err
		}
	    {
			keys := make([]string, 0, len(obj))
			for k := range obj {
				keys = append(keys, k)
			}
			sort.Strings(keys)
			for i := range keys {
				if i > 0 {
					if _, err := buf.WriteString(","); err != nil {
						return err
					}
				}
		    	{
					obj := keys[i]
		`, nil)
	g.emitMarshalerFor(tKey, sw)
	sw.Do(`
				}
				if _, err := buf.WriteString(":"); err != nil {
					return err
				}
				{
					obj := obj[keys[i]]
		`, nil)
	g.emitMarshalerFor(t.Elem, sw)
	sw.Do(`
				}
			}
		}
		if _, err := buf.WriteString("}"); err != nil {
			return err
		}
		`, nil)
	return nil
}

func (g *jsonGenerator) Finalize(c *generator.Context, w io.Writer) error {
	glog.V(5).Infof("Finalizing")
	sw := generator.NewSnippetWriter(w, c, "$", "$")
	for _, t := range g.builtinsNeeded {
		//FIXME: always take pointer?  benchmark
		//FIXME: this signature is a dup with above
		sw.Do("func Marshal_$.type|public$(obj $.type|raw$, buf *bytes.Buffer) error {\n", argsFromType(t))
		g.emitMarshalerForBuiltin(t, sw)
		sw.Do("\nreturn nil\n", nil)
		sw.Do("}\n", nil)
	}
	return sw.Error()
}

func (g *jsonGenerator) emitMarshalerForBuiltin(t *types.Type, sw *generator.SnippetWriter) {
	//FIXME: check inBounds?
	switch t {
	case types.String:
		//FIXME: escapes
		sw.Do(`
			if _, err := buf.Write([]byte("\"" + obj + "\"")); err != nil {
		    	return err
		    }
			`, nil)
	case types.Bool:
		sw.Do(`
			{
		    	var b []byte = falseBytes
		        if obj { b = trueBytes }
		        if _, err := buf.Write(b); err != nil {
		        	return err
		        }
			}
			`, nil)
	case types.Int, types.Int64, types.Int32, types.Int16:
		g.imports.Add("strconv")
		sw.Do(`
			if _, err := buf.WriteString(strconv.FormatInt(int64(obj), 10)); err != nil {
		    	return err
		    }
			`, nil)
	case types.Uint, types.Uint64, types.Uint32, types.Uint16, types.Uintptr, types.Byte:
		g.imports.Add("strconv")
		sw.Do(`
			if _, err := buf.WriteString(strconv.FormatUint(uint64(obj), 10)); err != nil {
		    	return err
		    }
			`, nil)
	case types.Float, types.Float64, types.Float32:
		g.imports.Add("strconv")
		sw.Do(`
			if _, err := buf.WriteString(strconv.FormatFloat(float64(obj), 'g', 64, 64)); err != nil {
		    	return err
		    }
			`, nil)
	}
}
