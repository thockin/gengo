/*
Copyright 2016 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package generators

import (
	"fmt"
	"io"
	"strings"
	"unicode"

	"k8s.io/gengo/args"
	"k8s.io/gengo/generator"
	"k8s.io/gengo/namer"
	"k8s.io/gengo/types"

	"github.com/golang/glog"
)

// CustomArgs is used tby the go2idl framework to pass args specific to this
// generator.
type CustomArgs struct {
	BoundingDirs []string // Only deal with types rooted under these dirs.
}

// This is the comment tag that carries parameters for deep-copy generation.
const tagName = "k8s:json-gen"

// Known values for the comment tag.
const tagValuePackage = "package"

// tagValue holds parameters from a tagName tag.
type tagValue struct {
	value string
}

func extractTag(comments []string) *tagValue {
	tagVals := types.ExtractCommentTags("+", comments)[tagName]
	if tagVals == nil {
		// No match for the tag.
		return nil
	}
	// If there are multiple values, abort.
	if len(tagVals) > 1 {
		glog.Fatalf("Found %d %s tags: %q", len(tagVals), tagName, tagVals)
	}

	// If we got here we are returning something.
	tag := &tagValue{}

	// Get the primary value.
	parts := strings.Split(tagVals[0], ",")
	if len(parts) >= 1 {
		tag.value = parts[0]
	}

	// Parse extra arguments.
	parts = parts[1:]
	for i := range parts {
		kv := strings.SplitN(parts[i], "=", 2)
		k := kv[0]
		v := ""
		if len(kv) == 2 {
			v = kv[1]
		}
		switch k {
		default:
			_ = k
			_ = v
			glog.Fatalf("Unsupported %s param: %q", tagName, parts[i])
		}
	}
	return tag
}

// FIXME: examine what we want to name things
func jsonNamer() *namer.NameStrategy {
	return &namer.NameStrategy{
		Join: func(pre string, in []string, post string) string {
			return strings.Join(in, "_")
		},
		PrependPackageNames: 1,
	}
}

// NameSystems returns the name system used by the generators in this package.
func NameSystems() namer.NameSystems {
	return namer.NameSystems{
		"public": jsonNamer(),
		"raw":    namer.NewRawNamer("", nil),
	}
}

// DefaultNameSystem returns the default name system for ordering the types to be
// processed by the generators in this package.
func DefaultNameSystem() string {
	return "public"
}

func Packages(context *generator.Context, arguments *args.GeneratorArgs) generator.Packages {
	boilerplate, err := arguments.LoadGoBoilerplate()
	if err != nil {
		glog.Fatalf("Failed loading boilerplate: %v", err)
	}

	header := append([]byte(fmt.Sprintf("// +build !%s\n\n", arguments.GeneratedBuildTag)), boilerplate...)
	header = append(header, []byte(
		`
// This file was autogenerated by json-gen. Do not edit it manually!

`)...)

	boundingDirs := []string{}
	if customArgs, ok := arguments.CustomArgs.(*CustomArgs); ok {
		for i := range customArgs.BoundingDirs {
			// Strip any trailing slashes - they are not exactly "correct" but
			// this is friendlier.
			boundingDirs = append(boundingDirs, strings.TrimRight(customArgs.BoundingDirs[i], "/"))
		}
	}

	// Results accumulator.
	packages := generator.Packages{}

	// De-dup inputs.
	inputs := map[string]bool{}
	for _, i := range context.Inputs {
		inputs[i] = true
	}

	for i := range inputs {
		glog.V(5).Infof("considering pkg %q", i)
		pkg := context.Universe[i]
		if pkg == nil {
			glog.V(5).Infof("package %q is nil in context.Universe: skipping", i)
			// If the input had no Go files, for example.
			continue
		}

		// Find the tags, if present.
		ptag := extractTag(pkg.Comments)
		ptagValue := ""
		if ptag != nil {
			ptagValue = ptag.value
			if ptagValue != tagValuePackage {
				glog.Fatalf("Package %v: unsupported %s value: %q", i, tagName, ptagValue)
			}
			glog.V(5).Infof("  tag.value: %q", ptagValue)
		} else {
			glog.V(5).Infof("  no tag")
		}

		// If the pkg-scoped tag says to generate, we can skip scanning types.
		pkgNeedsGeneration := (ptagValue == tagValuePackage)
		if !pkgNeedsGeneration {
			// If the pkg-scoped tag did not exist, scan all types for one that
			// explicitly wants generation.
			for _, t := range pkg.Types {
				glog.V(5).Infof("  considering type %q", t.Name.String())
				ttag := extractTag(t.CommentLines)
				if ttag != nil && ttag.value == "true" {
					glog.V(5).Infof("    tag=true")
					pkgNeedsGeneration = true
					break
				}
			}
		}

		if pkgNeedsGeneration {
			packages = append(packages,
				&generator.DefaultPackage{
					PackageName: pkg.Name,
					PackagePath: pkg.Path,
					HeaderText:  header,
					GeneratorFunc: func(c *generator.Context) (generators []generator.Generator) {
						return []generator.Generator{
							newGenerator(
								arguments.OutputFileBaseName, pkg.Path, //FIXME: use outputbase
								boundingDirs, (ptagValue == tagValuePackage)),
						}
					},
					FilterFunc: func(c *generator.Context, t *types.Type) bool {
						return t.Name.Package == pkg.Path
					},
				})
		}
	}
	return packages
}

// jsonGenerator produces a file with autogenerated deep-copy functions.
type jsonGenerator struct {
	generator.DefaultGen
	targetPackage  string
	boundingDirs   []string
	emitAllTypes   bool
	imports        namer.ImportTracker
	builtinsNeeded map[string]*types.Type
}

func newGenerator(sanitizedName string, targetPackage string, boundingDirs []string, emitAllTypes bool) generator.Generator {
	return &jsonGenerator{
		DefaultGen: generator.DefaultGen{
			OptionalName: sanitizedName,
		},
		targetPackage:  targetPackage,
		boundingDirs:   boundingDirs,
		emitAllTypes:   emitAllTypes,
		imports:        generator.NewImportTracker(),
		builtinsNeeded: map[string]*types.Type{},
	}
}

func (g *jsonGenerator) Namers(c *generator.Context) namer.NameSystems {
	// Have the raw namer for this file track what it imports.
	return namer.NameSystems{
		"raw": namer.NewRawNamer(g.targetPackage, g.imports),
	}
}

func (g *jsonGenerator) Filter(c *generator.Context, t *types.Type) bool {
	// Filter out types that are not being processed.
	if g.emitAllTypes {
		return true
	}
	if ttag := extractTag(t.CommentLines); ttag != nil && ttag.value == "true" {
		return true
	}
	return false
}

func (g *jsonGenerator) inBounds(t *types.Type) bool {
	// Only packages within the restricted range can be processed.
	if !isRootedUnder(t.Name.Package, g.boundingDirs) {
		return false
	}
	return true
}

func isRootedUnder(pkg string, roots []string) bool {
	// Add trailing / to avoid false matches, e.g. foo/bar vs foo/barn.  This
	// assumes that bounding dirs do not have trailing slashes.
	pkg = pkg + "/"
	for _, root := range roots {
		if strings.HasPrefix(string(pkg), string(root)+"/") {
			return true
		}
	}
	return false
}

var nameOfByteSlice = types.Name{Name: "[]byte"}
var nameOfError = types.Name{Name: "error"}

// hasMarshalMethod returns true if an appropriate MarshalJSON() method is
// defined for the given type.
func hasMarshalMethod(t *types.Type) bool {
	for mn, mt := range t.Methods {
		if mn != "MarshalJSON" {
			continue
		}
		if len(mt.Signature.Parameters) != 0 {
			return false
		}
		if len(mt.Signature.Results) != 2 ||
			mt.Signature.Results[0].Name != nameOfByteSlice ||
			mt.Signature.Results[1].Name != nameOfError {
			return false
		}
		return true
	}
	return false
}

func (g *jsonGenerator) isOtherPackage(importLine string) bool {
	if strings.HasSuffix(string(importLine), "\""+string(g.targetPackage)+"\"") {
		return false
	}
	return true
}

func (g *jsonGenerator) Imports(c *generator.Context) []string {
	importLines := []string{}
	for _, singleImport := range g.imports.ImportLines() {
		if g.isOtherPackage(singleImport) {
			importLines = append(importLines, singleImport)
		}
	}
	return importLines
}

func argsFromType(t *types.Type) generator.Args {
	return generator.Args{
		"type": t,
	}
}

func (g *jsonGenerator) Init(c *generator.Context, w io.Writer) error {
	g.imports.Add("k8s.io/gengo/examples/json-gen/libjson")
	sw := generator.NewSnippetWriter(w, c, "$", "$")
	//FIXME: register
	sw.Do("func init() {\n", nil)
	sw.Do("}\n", nil)
	return sw.Error()
}

func (g *jsonGenerator) GenerateType(c *generator.Context, t *types.Type, w io.Writer) error {
	glog.V(5).Infof("generating for type %v", t)
	if !g.needsGeneration(t) {
		glog.V(5).Infof("type %v does not need generation", t)
		return nil
	}

	sw := generator.NewSnippetWriter(w, c, "$", "$")
	g.emitFunctionsFor(t, g.emitMarshalerFor, c, sw)
	return sw.Error()
}

func (g *jsonGenerator) needsGeneration(t *types.Type) bool {
	if t.Kind == types.DeclarationOf {
		return false
	}

	tag := extractTag(t.CommentLines)
	tv := ""
	if tag != nil {
		tv = tag.value
		if tv != "true" && tv != "false" {
			glog.Fatalf("Type %v: unsupported %s value: %q", t, tagName, tag.value)
		}
	}
	if g.emitAllTypes && tv == "false" {
		// The whole package is being generated, but this type has opted out.
		glog.V(5).Infof("not generating for type %v because type opted out", t)
		return false
	}
	if !g.emitAllTypes && tv != "true" {
		// The whole package is NOT being generated, and this type has NOT opted in.
		glog.V(5).Infof("not generating for type %v because type did not opt in", t)
		return false
	}
	return true
}

func (g *jsonGenerator) emitFunctionsFor(t *types.Type, body func(t *types.Type, c *generator.Context) string, c *generator.Context, sw *generator.SnippetWriter) {
	g.imports.Add("bytes")
	//FIXME: use private names once they are registered
	sw.Do(`
		func Marshal_$.type|public$(obj $.type|raw$, buf *bytes.Buffer) error {
			val, err := ast_$.type|public$(obj)
			if err != nil {
				return err
			}
			return val.Render(buf)
		}
		func ast_$.type|public$(obj $.type|raw$) (libjson.Value, error) {
			`+body(t, c)+`
		}
		`, argsFromType(t))
}

// Just a shortcut helper function.
func formatName(c *generator.Context, namer string, t *types.Type) string {
	return c.Namers[namer].Name(t)
}

// emitMarshalerFor emits a block of code which returns a libjson.Value
// representing t, or an error.
func (g *jsonGenerator) emitMarshalerFor(t *types.Type, c *generator.Context) string {
	// If the type implements Marshaler on its own, use that.
	if hasMarshalMethod(t) {
		g.imports.Add("fmt")
		//FIME: shoiuld also handle MarsalText
		return `
			if b, err := obj.MarshalJSON(); err != nil {
				return nil, fmt.Errorf("failed to marshal %T: %v", obj, err)
			} else {
				return libjson.Raw(string(b)), nil
			}
			`
	}

	// Peel away a layer of alias.
	if t.Kind == types.Alias {
		t = t.Underlying
	}
	// Just call another function for simple cases.
	if t.Kind == types.Alias || t.Kind == types.Builtin {
		if t.Kind == types.Builtin {
			// We will emit common marshalers for builtins later.
			g.builtinsNeeded[t.String()] = t
		}
		return `return ast_` + formatName(c, "public", t) + `(` + formatName(c, "raw", t) + `(obj))`
	}

	var f func(*types.Type, *generator.Context) string

	// Handle more complex cases.  Each of these functions will emit a block
	// of code to marshal the respective types.  The emitted code should return
	// if it hits an error, but NOT if it is successful.  This allows these
	// blocks to be used in multiple contexts, and the contexts will handle
	// successful returns.
	//FIXME: check inBounds?
	switch t.Kind {
	case types.Pointer:
		f = g.emitMarshalerForPointer
	case types.Struct:
		f = g.emitMarshalerForStruct
	case types.Slice:
		f = g.emitMarshalerForSlice
	case types.Map:
		f = g.emitMarshalerForMap
	//FIXME: interfaces
	default:
		//FIXME: decide on error handling
		panic("unsupported kind: " + string(t.Kind) + " for type " + string(t.String()))
	}
	return f(t, c)
}

func (g *jsonGenerator) emitMarshalerForPointer(t *types.Type, c *generator.Context) string {
	return `
		if obj == nil {
			return libjson.Null{}, nil
		}
		return ast_` + formatName(c, "public", t.Elem) + `((` + formatName(c, "raw", t.Elem) + `)(*obj))
		`
}

type jsonTag struct {
	name      string
	omitempty bool
}

func (g *jsonGenerator) emitMarshalerForStruct(t *types.Type, c *generator.Context) string {
	result := `
		result := libjson.Object{}
		`

	if len(t.Members) == 0 {
		// at least do something with args to avoid "not used" errors
		result += "_ = obj\n"
	}

	structMeta := collectFields(t, 0, "")
	for _, name := range structMeta.FieldNames {
		field := structMeta.Fields[name]
		result += "// " + field.FieldName + "\n"
		//FIXME: register and provide a public func
		//FIXME: do these codeblocks as []string, to avoid the extra newlines in `...`
		result += `
			{
			    obj := obj.` + field.FieldName + `
				val, err := func() (libjson.Value, error) {` + g.emitMarshalerFor(field.Type, c) + `}()
				if err != nil {
					return nil, err
				}
				nv := libjson.NamedValue{
					Name: "` + name + `",
					Value: val,
				}
				result = append(result, nv)
			}
			`
		//FIXME: outdent trailing ` lines
	}
	result += `
	    return result, nil
		`
	return result
}

// Keep track of fields as we process embedded structs.  This is required to be
// compatible with Go's `json` package.
type fieldMeta struct {
	FieldName string
	Type      *types.Type
	Nesting   int
	Tagged    bool
}

type structMeta struct {
	Type       *types.Type
	FieldNames []string
	Fields     map[string]*fieldMeta
}

func newStructMeta(t *types.Type) structMeta {
	return structMeta{
		Type:       t,
		FieldNames: []string{},
		Fields:     map[string]*fieldMeta{},
	}
}

func mergeField(sm *structMeta, name string, fm *fieldMeta) {
	existing := sm.Fields[name]
	if existing == nil {
		sm.FieldNames = append(sm.FieldNames, name)
		sm.Fields[name] = fm
	} else if existing.Nesting != fm.Nesting {
		keep := existing
		drop := fm
		if fm.Nesting < existing.Nesting {
			sm.Fields[name] = fm
			keep = fm
			drop = existing
		}
		glog.Errorf("WARNING: JSON field %s.%s conflict: keeping %s, dropping %s (less nested)", sm.Type, name, keep.FieldName, drop.FieldName)
	} else if existing.Tagged != fm.Tagged {
		keep := existing
		drop := fm
		if fm.Tagged {
			sm.Fields[name] = fm
			keep = fm
			drop = existing
		}
		glog.Errorf("WARNING: JSON field %s.%s conflict: keeping %s, dropping %s (tagged)", sm.Type, name, keep.FieldName, drop.FieldName)
	} else {
		glog.Errorf("WARNING: JSON field %s.%s conflict: dropping both %s and %s", sm.Type, name, existing.FieldName, fm.FieldName)
	}
}

// collectFields returns a flattened map of field information for the given
// type. This processes embedded fields according to Go's `json` package docs.
func collectFields(t *types.Type, nesting int, fieldpath string) structMeta {
	structMeta := newStructMeta(t)

	for _, m := range t.Members {
		fm := &fieldMeta{
			FieldName: prefixFieldName(m.Name, fieldpath),
			Type:      m.Type,
			Nesting:   nesting,
		}

		name := ""
		if m.Tags != "" {
			glog.V(3).Infof("found struct tags for %v.%s", t, m.Name)
			tag, err := parseTag(m.Tags)
			if err != nil {
				panic(fmt.Sprintf("failed to parse struct tag for %s.%s: %v", t, m.Name, err))
			}
			name = tag.name
			if name == "-" {
				// Skip this field
				continue
			}
			fm.Tagged = true
			//FIXME: handle omitempty
		}
		//FIXME: handle the 'string' tag option
		if name == "" {
			name = m.Name
		}

		// If the field is either not embedded or is not a struct (e.g. an
		// embedded string), save it.
		if !m.Embedded || m.Type.Kind != types.Struct {
			mergeField(&structMeta, name, fm)
			continue
		}

		embeddedStructMeta := collectFields(m.Type, nesting+1, prefixFieldName(m.Name, fieldpath))
		for _, name := range embeddedStructMeta.FieldNames {
			field := embeddedStructMeta.Fields[name]
			mergeField(&structMeta, name, field)
		}
	}
	return structMeta
}

func prefixFieldName(name string, path string) string {
	if path == "" {
		return name
	}
	return path + "." + name
}

type kv struct {
	key string
	val string
}

const (
	stateKey = iota
	stateColon
	stateValue
	stateEscape
)

func parseTag(str string) (jsonTag, error) {
	tags := []kv{}

	key := ""
	val := ""
	state := stateKey
	pos := 0
	for _, r := range str {
		switch state {
		case stateKey:
			//FIXME: look up spec for tag names
			if unicode.IsLetter(r) || unicode.IsNumber(r) || r == '_' || r == '.' {
				key += string(r)
			} else if r == ':' {
				state = stateColon
			} else {
				return jsonTag{}, fmt.Errorf("unexpected character[%d] '%v' parsing tag name", pos, r)
			}
		case stateColon:
			if r == '"' {
				state = stateValue
			} else {
				return jsonTag{}, fmt.Errorf("unexpected character[%d] '%v' parsing tag value", pos, r)
			}
		case stateValue:
			if r == '\\' {
				state = stateEscape
			} else if r == '"' {
				glog.V(5).Infof("parsed tag %s:%q", key, val)
				tags = append(tags, kv{key: key, val: val})
				state = stateKey
			} else {
				val += string(r)
			}
		case stateEscape:
			//FIXME: look up what escapes are supported
			val += string(r)
		}
		pos++
	}

	result := jsonTag{}
	for _, tag := range tags {
		if tag.key != "json" {
			continue
		}
		parts := strings.Split(tag.val, ",")
		if len(parts) >= 1 {
			result.name = parts[0]
		}
		for i := 1; i < len(parts); i++ {
			if parts[i] == "omitempty" {
				result.omitempty = true
			} else {
				return jsonTag{}, fmt.Errorf("unexpected tag-item %q in json tag", parts[i])
			}
		}
	}
	return result, nil
}

func (g *jsonGenerator) emitMarshalerForSlice(t *types.Type, c *generator.Context) string {
	result := `
		if obj == nil {
			return libjson.Null{}, nil
		}
		`
	if rootType(t.Elem) == types.Byte {
		// Go's json package special-cases []byte
		g.imports.Add("encoding/base64")
		result += `
			buf := bytes.Buffer{}
			b64 := base64.NewEncoder(base64.StdEncoding, &buf)
			`
		if t.Elem == types.Byte {
			result += `
				b64.Write(obj)
				`
		} else {
			// Can't just cast []ByteAlias to []byte. :(
			result += `
				for _, b := range obj {
					b64.Write([]byte{byte(b)})
				}
				`
		}
		result += `
			b64.Close()
			return libjson.String(buf.String()), nil
			`
	} else {
		result += `
			result := libjson.Array{}
			for i := range obj {
				obj := obj[i]
				val, err := func() (libjson.Value, error) {` + g.emitMarshalerFor(t.Elem, c) + `}()
				if err != nil {
					return nil, err
				}
				result = append(result, val)
			}
	    	return result, nil
		`
	}
	return result
}

func rootType(t *types.Type) *types.Type {
	// Peel away layers of alias.
	for t.Kind == types.Alias {
		t = t.Underlying
	}
	return t
}

func (g *jsonGenerator) emitMarshalerForMap(t *types.Type, c *generator.Context) string {
	result := ""

	// Map keys must be strings or ints.
	//FIXME: encoding.TextMarshaler.MarshalText
	switch rootType(t.Key) {
	case types.String:
		result += `
			stringify := func(s ` + formatName(c, "raw", t.Key) + `) string { return string(s) }
			`
	case types.Int, types.Int64, types.Int32, types.Int16, types.Int8:
		g.imports.Add("strconv")
		result += `
			stringify := func(i ` + formatName(c, "raw", t.Key) + `) string { return strconv.FormatInt(int64(i), 10) }
			`
	case types.Uint, types.Uint64, types.Uint32, types.Uint16, types.Uint8, types.Uintptr:
		g.imports.Add("strconv")
		result += `
			stringify := func(i ` + formatName(c, "raw", t.Key) + `) string { return strconv.FormatUint(uint64(i), 10) }
			`
	default:
		//FIXME: do beter than panic?
		panic(fmt.Sprintf("map key must be string or int (%v)", t.Key))
	}

	//FIXME: sort ints by number?
	g.imports.Add("sort")
	return result + `
		m := make(map[string]libjson.Value, len(obj))
		keys := make([]string, 0, len(obj))
		for k, v := range obj {
			ks := stringify(k)
			keys = append(keys, ks)
			obj := v
			jv, err := func() (libjson.Value, error) {` + g.emitMarshalerFor(t.Elem, c) + `}()
			if err != nil {
				return nil, err
			}
			m[ks] = jv
		}
		result := libjson.Object{}
		sort.Strings(keys)
		for _, ks := range keys {
			nv := libjson.NamedValue{
				Name: ks,
				Value: m[ks],
			}
			result = append(result, nv)
		}
	    return result, nil
		`
}

func (g *jsonGenerator) Finalize(c *generator.Context, w io.Writer) error {
	glog.V(5).Infof("Finalizing")
	sw := generator.NewSnippetWriter(w, c, "$", "$")
	for _, t := range g.builtinsNeeded {
		//FIXME: always take pointer?  benchmark
		g.emitFunctionsFor(t, g.emitMarshalerForBuiltin, c, sw)
	}
	return sw.Error()
}

func (g *jsonGenerator) emitMarshalerForBuiltin(t *types.Type, c *generator.Context) string {
	switch t {
	case types.String:
		return `return libjson.String(obj), nil`
	case types.Bool:
		return `return libjson.Bool(obj), nil`
	case types.Int, types.Int64, types.Int32, types.Int16, types.Int8:
		fallthrough
	case types.Uint, types.Uint64, types.Uint32, types.Uint16, types.Uint8, types.Uintptr, types.Byte:
		//FIXME: test byte in stdlib
		fallthrough
	case types.Float, types.Float64, types.Float32:
		return `return libjson.Number(float64(obj)), nil`
	default:
		//FIXME: glog and exit?
		panic("unknown builtin \"" + t.String() + "\"")
	}
}
