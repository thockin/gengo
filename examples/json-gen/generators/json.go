/*
Copyright 2016 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package generators

import (
	"fmt"
	"io"
	"reflect"
	"strings"

	"k8s.io/gengo/args"
	"k8s.io/gengo/generator"
	"k8s.io/gengo/namer"
	"k8s.io/gengo/types"

	"github.com/golang/glog"
)

// CustomArgs is used tby the go2idl framework to pass args specific to this
// generator.
type CustomArgs struct {
	BoundingDirs []string // Only deal with types rooted under these dirs.
}

// This is the comment tag that carries parameters for deep-copy generation.
const tagName = "k8s:json-gen"

// Known values for the comment tag.
const tagValuePackage = "package"

// tagValue holds parameters from a tagName tag.
type tagValue struct {
	value string
}

func extractTag(comments []string) *tagValue {
	tagVals := types.ExtractCommentTags("+", comments)[tagName]
	if tagVals == nil {
		// No match for the tag.
		return nil
	}
	// If there are multiple values, abort.
	if len(tagVals) > 1 {
		glog.Fatalf("Found %d %s tags: %q", len(tagVals), tagName, tagVals)
	}

	// If we got here we are returning something.
	tag := &tagValue{}

	// Get the primary value.
	parts := strings.Split(tagVals[0], ",")
	if len(parts) >= 1 {
		tag.value = parts[0]
	}

	// Parse extra arguments.
	parts = parts[1:]
	for i := range parts {
		kv := strings.SplitN(parts[i], "=", 2)
		k := kv[0]
		v := ""
		if len(kv) == 2 {
			v = kv[1]
		}
		switch k {
		default:
			_ = k
			_ = v
			glog.Fatalf("Unsupported %s param: %q", tagName, parts[i])
		}
	}
	return tag
}

func jsonNamer() *namer.NameStrategy {
	return &namer.NameStrategy{
		Join: func(pre string, in []string, post string) string {
			return strings.Join(in, "_")
		},
		PrependPackageNames: 1,
	}
}

// NameSystems returns the name system used by the generators in this package.
func NameSystems() namer.NameSystems {
	return namer.NameSystems{
		"public": jsonNamer(),
		"raw":    namer.NewRawNamer("", nil),
	}
}

// DefaultNameSystem returns the default name system for ordering the types to be
// processed by the generators in this package.
func DefaultNameSystem() string {
	return "public"
}

func Packages(context *generator.Context, arguments *args.GeneratorArgs) generator.Packages {
	boilerplate, err := arguments.LoadGoBoilerplate()
	if err != nil {
		glog.Fatalf("Failed loading boilerplate: %v", err)
	}

	header := append([]byte(fmt.Sprintf("// +build !%s\n\n", arguments.GeneratedBuildTag)), boilerplate...)
	header = append(header, []byte(
		`
		// This file was autogenerated by json-gen. Do not edit it manually!

		`)...)

	boundingDirs := []string{}
	if customArgs, ok := arguments.CustomArgs.(*CustomArgs); ok {
		for i := range customArgs.BoundingDirs {
			// Strip any trailing slashes - they are not exactly "correct" but
			// this is friendlier.
			boundingDirs = append(boundingDirs, strings.TrimRight(customArgs.BoundingDirs[i], "/"))
		}
	}

	// Results accumulator.
	packages := generator.Packages{}

	// De-dup inputs.
	inputs := map[string]bool{}
	for _, i := range context.Inputs {
		inputs[i] = true
	}

	for i := range inputs {
		glog.V(5).Infof("considering pkg %q", i)
		pkg := context.Universe[i]
		if pkg == nil {
			glog.V(5).Infof("package %q is nil in context.Universe: skipping", i)
			// If the input had no Go files, for example.
			continue
		}

		// Find the tags, if present.
		ptag := extractTag(pkg.DocComments)
		ptagValue := ""
		if ptag != nil {
			ptagValue = ptag.value
			if ptagValue != tagValuePackage {
				glog.Fatalf("Package %v: unsupported %s value: %q", i, tagName, ptagValue)
			}
			glog.V(5).Infof("  tag.value: %q", ptagValue)
		} else {
			glog.V(5).Infof("  no tag")
		}

		// If the pkg-scoped tag says to generate, we can skip scanning types.
		pkgNeedsGeneration := (ptagValue == tagValuePackage)
		if !pkgNeedsGeneration {
			// If the pkg-scoped tag did not exist, scan all types for one that
			// explicitly wants generation.
			for _, t := range pkg.Types {
				glog.V(5).Infof("  considering type %q", t.Name.String())
				ttag := extractTag(t.CommentLines)
				if ttag != nil && ttag.value == "true" {
					glog.V(5).Infof("    tag=true")
					pkgNeedsGeneration = true
					break
				}
			}
		}

		if pkgNeedsGeneration {
			packages = append(packages,
				&generator.DefaultPackage{
					PackageName: pkg.Name,
					PackagePath: pkg.Path,
					HeaderText:  header,
					GeneratorFunc: func(c *generator.Context) (generators []generator.Generator) {
						return []generator.Generator{
							newGenerator(
								arguments.OutputFileBaseName, pkg.Path, //FIXME: use outputbase
								boundingDirs, (ptagValue == tagValuePackage)),
						}
					},
					FilterFunc: func(c *generator.Context, t *types.Type) bool {
						return t.Name.Package == pkg.Path
					},
				})
		}
	}
	return packages
}

// jsonGenerator produces a file with autogenerated deep-copy functions.
type jsonGenerator struct {
	generator.DefaultGen
	targetPackage string
	boundingDirs  []string
	emitAllTypes  bool
	imports       namer.ImportTracker
	astEmitted    map[string]bool
	astNeeded     []*types.Type
}

func newGenerator(sanitizedName string, targetPackage string, boundingDirs []string, emitAllTypes bool) generator.Generator {
	return &jsonGenerator{
		DefaultGen: generator.DefaultGen{
			OptionalName: sanitizedName,
		},
		targetPackage: targetPackage,
		boundingDirs:  boundingDirs,
		emitAllTypes:  emitAllTypes,
		imports:       generator.NewImportTracker(),
		astEmitted:    map[string]bool{},
	}
}

func (g *jsonGenerator) Namers(c *generator.Context) namer.NameSystems {
	// Have the raw namer for this file track what it imports.
	return namer.NameSystems{
		"raw": namer.NewRawNamer(g.targetPackage, g.imports),
	}
}

func (g *jsonGenerator) Filter(c *generator.Context, t *types.Type) bool {
	// Filter out types that are not being processed.
	if g.emitAllTypes {
		return true
	}
	if ttag := extractTag(t.CommentLines); ttag != nil && ttag.value == "true" {
		return true
	}
	return false
}

func (g *jsonGenerator) inBounds(t *types.Type) bool {
	// Only packages within the restricted range can be processed.
	if !isRootedUnder(t.Name.Package, g.boundingDirs) {
		return false
	}
	return true
}

func isRootedUnder(pkg string, roots []string) bool {
	// Add trailing / to avoid false matches, e.g. foo/bar vs foo/barn.  This
	// assumes that bounding dirs do not have trailing slashes.
	pkg = pkg + "/"
	for _, root := range roots {
		if strings.HasPrefix(string(pkg), string(root)+"/") {
			return true
		}
	}
	return false
}

var nameOfByteSlice = types.Name{Name: "[]byte"}
var nameOfError = types.Name{Name: "error"}

// hasMarshalMethod looks for a method with the same signature as MarshalJSON.
func hasMarshalMethod(t *types.Type, name string) bool {
	for mn, mt := range t.Methods {
		if mn != name {
			continue
		}
		if len(mt.Signature.Parameters) != 0 {
			return false
		}
		if len(mt.Signature.Results) != 2 ||
			mt.Signature.Results[0].Name != nameOfByteSlice ||
			mt.Signature.Results[1].Name != nameOfError {
			return false
		}
		return true
	}
	return false
}

// hasUnmarshalMethod looks for a method with the same signature as UnmarshalJSON.
func hasUnmarshalMethod(t *types.Type, name string) bool {
	for mn, mt := range t.Methods {
		if mn != name {
			continue
		}
		if len(mt.Signature.Parameters) != 1 || mt.Signature.Parameters[0].Name != nameOfByteSlice {
			return false
		}
		if len(mt.Signature.Results) != 1 || mt.Signature.Results[0].Name != nameOfError {
			return false
		}
		return true
	}
	return false
}

// hasJSONMarshalMethod returns true if an appropriate MarshalJSON() method is
// defined for the given type.
func hasJSONMarshalMethod(t *types.Type) bool {
	return hasMarshalMethod(t, "MarshalJSON")
}

// hasJSONUnmarshalMethod returns true if an appropriate UnmarshalJSON() method is
// defined for the given type.
func hasJSONUnmarshalMethod(t *types.Type) bool {
	return hasUnmarshalMethod(t, "UnmarshalJSON")
}

// hasTextMarshalMethod returns true if an appropriate MarshalText() method is
// defined for the given type.
func hasTextMarshalMethod(t *types.Type) bool {
	return hasMarshalMethod(t, "MarshalText")
}

// hasTextUnmarshalMethod returns true if an appropriate UnmarshalText() method is
// defined for the given type.
func hasTextUnmarshalMethod(t *types.Type) bool {
	return hasUnmarshalMethod(t, "UnmarshalText")
}

func (g *jsonGenerator) isOtherPackage(importLine string) bool {
	if strings.HasSuffix(string(importLine), "\""+string(g.targetPackage)+"\"") {
		return false
	}
	return true
}

func (g *jsonGenerator) Imports(c *generator.Context) []string {
	importLines := []string{}
	for _, singleImport := range g.imports.ImportLines() {
		if g.isOtherPackage(singleImport) {
			importLines = append(importLines, singleImport)
		}
	}
	return importLines
}

func argsFromType(t *types.Type) generator.Args {
	return generator.Args{
		"type": t,
	}
}

func (g *jsonGenerator) Init(c *generator.Context, w io.Writer) error {
	glog.V(0).Infof("processing %s", g.targetPackage)
	g.imports.Add("k8s.io/gengo/examples/json-gen/libjson")
	return nil
}

func (g *jsonGenerator) GenerateType(c *generator.Context, t *types.Type, w io.Writer) error {
	glog.V(5).Infof("generating for type %v", t)
	if !g.needsGeneration(t) {
		glog.V(5).Infof("type %v does not need generation", t)
		return nil
	}

	sw := generator.NewSnippetWriter(w, c, "$", "$")
	g.emitMethods(t, sw)
	g.emitAST(t, c, sw)
	return sw.Error()
}

func (g *jsonGenerator) needsGeneration(t *types.Type) bool {
	if t.Kind == types.DeclarationOf {
		return false
	}

	tag := extractTag(t.CommentLines)
	tv := ""
	if tag != nil {
		tv = tag.value
		if tv != "true" && tv != "false" {
			glog.Fatalf("Type %v: unsupported %s value: %q", t, tagName, tag.value)
		}
	}
	if g.emitAllTypes && tv == "false" {
		// The whole package is being generated, but this type has opted out.
		glog.V(5).Infof("not generating for type %v because type opted out", t)
		return false
	}
	if !g.emitAllTypes && tv != "true" {
		// The whole package is NOT being generated, and this type has NOT opted in.
		glog.V(5).Infof("not generating for type %v because type did not opt in", t)
		return false
	}
	return true
}

func (g *jsonGenerator) emitAST(t *types.Type, c *generator.Context, sw *generator.SnippetWriter) {
	glog.V(3).Infof("emitting AST code for type %v", t)
	sw.Do(`
		func ast_$.type|public$(obj *$.type|raw$) (libjson.Value, error) {
			`+g.emitBodyFor(t, c)+`
		}
		`, argsFromType(t))
	g.astEmitted[t.String()] = true

}

func (g *jsonGenerator) emitMethods(t *types.Type, sw *generator.SnippetWriter) {
	if rootType(t).Kind == types.Pointer {
		//FIXME: should be fatal?
		glog.Errorf("not emitting methods for pointer type %v", t)
		return
	}
	// If the type has both JSON methods, do not emit our own.
	if m, u := hasJSONMarshalMethod(t), hasJSONUnmarshalMethod(t); m || u {
		// We don't handle asymmetric types for now.  Someone show me a
		// use-case.
		if m && !u {
			//FIXME: better to return
			panic(fmt.Sprintf("type %v has a MarshalJSON method but not UnmarshalJSON"))
		}
		if !m && u {
			//FIXME: better to return
			panic(fmt.Sprintf("type %v has an UnmarshalJSON method but not MarshalJSON"))
		}
	} else {
		glog.V(0).Infof("emitting JSON methods for %s", t.Name.Name)
		g.imports.Add("bytes")
		sw.Do(`
			func (obj $.type|raw$) MarshalJSON() ([]byte, error) {
				jv, err := ast_$.type|public$(&obj)
				if err != nil {
					return nil, err
				}
				var buf bytes.Buffer
				if err := jv.Render(&buf); err != nil {
					return nil, err
				}
				return buf.Bytes(), nil
			}
			func (obj *$.type|raw$) UnmarshalJSON(data []byte) error {
				jv, err := ast_$.type|public$(obj)
				if err != nil {
					return err
				}
				return jv.Parse(data)
			}
			`, argsFromType(t))
	}
}

// Just a shortcut helper function.
func formatName(c *generator.Context, namer string, t *types.Type) string {
	return c.Namers[namer].Name(t)
}

// emitBodyFor emits a block of code which returns a libjson.Value
// representing an instance of t, or an error.
func (g *jsonGenerator) emitBodyFor(t *types.Type, c *generator.Context) string {
	// If the type implements json.Marshaler and json.Unmarshaler on its own,
	// use them.
	if m, u := hasJSONMarshalMethod(t), hasJSONUnmarshalMethod(t); m || u {
		if m && !u {
			//FIXME: better to return
			panic(fmt.Sprintf("type %v has a MarshalJSON method but not UnmarshalJSON"))
		}
		if !m && u {
			//FIXME: better to return
			panic(fmt.Sprintf("type %v has an UnmarshalJSON method but not MarshalJSON"))
		}
		glog.V(3).Infof("type %v has JSON marshaling methods", t)
		return `
			return libjson.NewRaw(obj.MarshalJSON, obj.UnmarshalJSON), nil
			`
	}
	// If the type implements encoding.TextMarshaler and encoding.TextUnmarshaler,
	// use them.
	if m, u := hasTextMarshalMethod(t), hasTextUnmarshalMethod(t); m || u {
		if m && !u {
			//FIXME: better to return
			panic(fmt.Sprintf("type %v has a MarshalText method but not UnmarshalText"))
		}
		if !m && u {
			//FIXME: better to return
			panic(fmt.Sprintf("type %v has an UnmarshalText method but not MarshalText"))
		}
		glog.V(3).Infof("type %v has text marshaling methods", t)
		return `
			marshal := func() ([]byte, error) {
				t, err := obj.MarshalText()
				if err != nil {
					return nil, err
				}
				return append(append([]byte{'"'}, t...), '"'), nil
			}
			unmarshal := func(text []byte) error {
				return obj.UnmarshalText(text[1:len(text)-1])
			}
			return libjson.NewRaw(marshal, unmarshal), nil
			`
	}

	// Just call another function for simple cases.
	if t.Kind == types.Alias {
		glog.V(4).Infof("type %v is alias to %v", t, t.Underlying)
		return `return ` + g.emitCallFor(t.Underlying, c)
	}

	var f func(*types.Type, *generator.Context) string

	// Handle more complex cases.  Each of these functions will emit a block
	// of code to marshal the respective types.  The emitted code should return
	// if it hits an error, but NOT if it is successful.  This allows these
	// blocks to be used in multiple contexts, and the contexts will handle
	// successful returns.
	glog.V(4).Infof("type %v is kind %s", t, t.Kind)
	switch t.Kind {
	case types.Builtin:
		f = g.emitBodyForBuiltin
	case types.Pointer:
		f = g.emitBodyForPointer
	case types.Struct:
		f = g.emitBodyForStruct
	case types.Slice:
		f = g.emitBodyForSlice
	case types.Map:
		f = g.emitBodyForMap
	default:
		// A reasonable argument could be made to just ignore it, but I'd
		// rather know if this happens.  The likely case is interfaces which,
		// obviously, we can't codegen for.
		panic("unsupported kind: " + string(t.Kind) + " for type " + string(t.String()))
	}
	return f(t, c)
}

func (g *jsonGenerator) emitCallFor(t *types.Type, c *generator.Context) string {
	g.astNeeded = append(g.astNeeded, t)
	return `ast_` + formatName(c, "public", t) + `((*` + formatName(c, "raw", t) + `)(obj))`
}

func (g *jsonGenerator) emitBodyForPointer(t *types.Type, c *generator.Context) string {
	return `
		var jv libjson.Value
		var err error
		if *obj != nil {
			obj := *obj
			jv, err = ` + g.emitCallFor(t.Elem, c) + `
			if err != nil {
				return nil, err
			}
		}
		setNull := func(b bool) (libjson.Value, error) {
			if b {
				*obj = nil
				return nil, nil
			}
			*obj = new(` + formatName(c, "raw", t.Elem) + `)
			obj := *obj
			return ` + g.emitCallFor(t.Elem, c) + `
		}
		return libjson.NewNullable(jv, setNull), nil
		`
}

func (g *jsonGenerator) emitBodyForStruct(t *types.Type, c *generator.Context) string {
	result := `
		result := libjson.NewObject()
		`

	if len(t.Members) == 0 {
		// at least do something with args to avoid "not used" errors
		result += "_ = obj\n"
	}

	structMeta := collectFields(t, 0, "")
	for _, name := range structMeta.FieldNames {
		field := structMeta.Fields[name]
		glog.V(4).Infof("descending into field %v.%s (omitempty=%v)", t, field.FieldName, field.OmitEmpty)

		result += `
			// ` + field.FieldName + ` ` + field.Type.String() + `
			{
			    obj := &obj.` + field.FieldName + `
			`

		if field.String {
			glog.V(4).Infof("field %v.%s has string tag", t, field.FieldName)
			result += `
				finalize := func(jv libjson.Value) (libjson.Value, error) {
					buf := bytes.Buffer{}
					if err := jv.Render(&buf); err != nil {
						return nil, err
					}
					p := new(string)
					*p = buf.String()
					return libjson.NewString(func() string { return *p }, func(s string) { *p = s }), nil
				}
				`
		} else {
			result += `
				finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }
				`
		}

		result += `
				jv, err := ` + g.emitCallFor(field.Type, c) + `
				if err != nil {
					return nil, err
				}
				fv, err := finalize(jv)
				if err != nil {
					return nil, err
				}
				p := new(string)
				*p = "` + name + `"
				nv := libjson.NamedValue{
					Name: libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
					Value: fv,
					OmitEmpty: ` + fmt.Sprintf("%v", field.OmitEmpty) + `, 
				}
				result = append(result, nv)
			}
			`
	}
	result += `
	    return result, nil
		`
	return result
}

// Keep track of fields as we process embedded structs.  This is required to be
// compatible with Go's `json` package.
type fieldMeta struct {
	FieldName string
	Type      *types.Type
	Nesting   int  // how many nesting levels
	Tagged    bool // had a tag-defined name
	OmitEmpty bool // the `omitempty` tag opion
	String    bool // the `string` tag option
}

type structMeta struct {
	Type       *types.Type
	FieldNames []string
	Fields     map[string]*fieldMeta
}

func newStructMeta(t *types.Type) structMeta {
	return structMeta{
		Type:       t,
		FieldNames: []string{},
		Fields:     map[string]*fieldMeta{},
	}
}

func mergeField(sm *structMeta, name string, fm *fieldMeta) {
	existing := sm.Fields[name]
	if existing == nil {
		sm.FieldNames = append(sm.FieldNames, name)
		sm.Fields[name] = fm
	} else if existing.Nesting != fm.Nesting {
		keep := existing
		drop := fm
		if fm.Nesting < existing.Nesting {
			sm.Fields[name] = fm
			keep = fm
			drop = existing
		}
		glog.Errorf("WARNING: JSON field %s.%s conflict: keeping %s, dropping %s (less nested)", sm.Type, name, keep.FieldName, drop.FieldName)
	} else if existing.Tagged != fm.Tagged {
		keep := existing
		drop := fm
		if fm.Tagged {
			sm.Fields[name] = fm
			keep = fm
			drop = existing
		}
		glog.Errorf("WARNING: JSON field %s.%s conflict: keeping %s, dropping %s (tagged)", sm.Type, name, keep.FieldName, drop.FieldName)
	} else {
		glog.Errorf("WARNING: JSON field %s.%s conflict: dropping both %s and %s", sm.Type, name, existing.FieldName, fm.FieldName)
	}
}

// collectFields returns a flattened map of field information for the given
// type. This processes embedded fields according to Go's `json` package docs.
func collectFields(t *types.Type, nesting int, fieldpath string) structMeta {
	structMeta := newStructMeta(t)

	for _, m := range t.Members {
		fm := &fieldMeta{
			FieldName: prefixFieldName(m.Name, fieldpath),
			Type:      m.Type,
			Nesting:   nesting,
		}

		name := ""
		if m.Tags != "" {
			glog.V(3).Infof("found struct tags for %v.%s", t, m.Name)
			tag := parseTag(m.Tags)
			name = tag.name
			if name == "-" {
				// Skip this field
				continue
			}
			fm.Tagged = true
			fm.OmitEmpty = tag.omitEmpty
			fm.String = tag.asString
		}
		if name == "" {
			name = m.Name
		}

		// If the field is either not embedded or is not a struct (e.g. an
		// embedded string), save it.
		if !m.Embedded || m.Type.Kind != types.Struct {
			mergeField(&structMeta, name, fm)
			continue
		}

		embeddedStructMeta := collectFields(m.Type, nesting+1, prefixFieldName(m.Name, fieldpath))
		for _, name := range embeddedStructMeta.FieldNames {
			field := embeddedStructMeta.Fields[name]
			mergeField(&structMeta, name, field)
		}
	}
	return structMeta
}

func prefixFieldName(name string, path string) string {
	if path == "" {
		return name
	}
	return path + "." + name
}

type jsonTag struct {
	name      string
	omitEmpty bool
	asString  bool
}

func parseTag(str string) jsonTag {
	tag := reflect.StructTag(str)

	result := jsonTag{}

	jt := tag.Get("json")
	parts := strings.Split(jt, ",")
	if len(parts) >= 1 {
		result.name = parts[0]
	}
	for i := 1; i < len(parts); i++ {
		if parts[i] == "omitempty" {
			result.omitEmpty = true
		} else if parts[i] == "string" {
			result.asString = true
		} else {
			glog.Errorf("WARNING: unknown json tag option %q in json tag", parts[i])
		}
	}
	return result
}

func (g *jsonGenerator) emitBodyForSlice(t *types.Type, c *generator.Context) string {
	//FIXME: need rootType here and elsewhere?
	// Go's json package special-cases []byte and []uint8
	if rootType(t.Elem) == types.Byte || rootType(t.Elem) == types.Uint8 {
		result := ""
		if t.Elem == types.Byte {
			result += `
				get := func() []byte {
					return *obj
				}
				set := func(bs []byte) {
					*obj = bs
				}
				`
		} else {
			// Can't just cast []ByteAlias to []byte. :(
			result += `
				get := func() []byte {
					bs := make([]byte, len(*obj))
					for i, b := range *obj {
						bs[i] = byte(b)
					}
					return bs
				}
				set := func(bs []byte) {
					*obj = make([]` + formatName(c, "raw", t.Elem) + `, len(bs))
					for i, b := range bs {
						(*obj)[i] = ` + formatName(c, "raw", t.Elem) + `(b)
					}
				}
				`
		}
		result += `
			var jv libjson.Value
			if *obj != nil {
				jv = libjson.NewBytes(get, set)
			}
			setNull := func(b bool) (libjson.Value, error) {
				if b {
					*obj = nil
					return nil, nil
				}
				*obj = []` + formatName(c, "raw", t.Elem) + `{}
				return libjson.NewBytes(get, set), nil
			}
			return libjson.NewNullable(jv, setNull), nil
			`
		return result
	}

	return `
		get := func() ([]libjson.Value, error) {
			if *obj == nil {
				return nil, nil
			}
			result := []libjson.Value{}
			for i := range *obj {
				obj := &(*obj)[i]
				//FIXME: do any of these ACTUALLY return an error?
				jv, err := ` + g.emitCallFor(t.Elem, c) + `
				if err != nil {
					return nil, err
				}
				result = append(result, jv)
			}
			return result, nil
		}
		add := func() libjson.Value {
			var x ` + formatName(c, "raw", t.Elem) + `
			*obj = append(*obj, x)
			obj := &(*obj)[len(*obj)-1]
			jv, _ := ` + g.emitCallFor(t.Elem, c) + `
			//FIXME: handle error?
			return jv
		}
		var jv libjson.Value
		if *obj != nil {
			jv = libjson.NewArray(get, add)
		}
		setNull := func(b bool) (libjson.Value, error) {
			if b {
				*obj = nil
				return nil, nil
			}
			*obj = ` + formatName(c, "raw", t) + `{}
			return libjson.NewArray(get, add), nil
		}
		return libjson.NewNullable(jv, setNull), nil
		`
}

func rootType(t *types.Type) *types.Type {
	// Peel away layers of alias.
	for t.Kind == types.Alias {
		t = t.Underlying
	}
	return t
}

func (g *jsonGenerator) emitBodyForMap(t *types.Type, c *generator.Context) string {
	result := ""

	result += g.emitKeyToString(t, c)
	result += g.emitKeyFromString(t, c)

	return result + `
		var keys []` + formatName(c, "raw", t.Key) + `
		var vals []` + formatName(c, "raw", t.Elem) + `
		add := func(ks string) libjson.Value {
			if k, err := keyFromString(ks); err != nil {
				panic(err) //FIXME
			} else {
				keys = append(keys, k)
			}
			var x ` + formatName(c, "raw", t.Elem) + `
			vals = append(vals, x)
			obj := &vals[len(vals)-1]
			jv, _ := ` + g.emitCallFor(t.Elem, c) + `
			//FIXME: handle error?
			return jv
		}
		get := func() (map[string]libjson.Value, error) {
			if *obj == nil && keys == nil {
				return nil, nil
			}
			result := map[string]libjson.Value{}
			for k, v := range *obj {
				obj := new(` + formatName(c, "raw", t.Elem) + `)
				*obj = v
				//FIXME: do any of these ACTUALLY return an error?
				jv, err := ` + g.emitCallFor(t.Elem, c) + `
				if err != nil {
					return nil, err
				}
				if ks, err := keyToString(k); err != nil {
					panic(err)
				} else {
					result[ks] = jv
				}
			}
			for i := range keys {
				obj := &vals[i]
				//FIXME: do any of these ACTUALLY return an error?
				jv, err := ` + g.emitCallFor(t.Elem, c) + `
				if err != nil {
					return nil, err
				}
				if ks, err := keyToString(keys[i]); err != nil {
					panic(err)
				} else {
					result[ks] = jv
				}
			}
			return result, nil
		}
		finishParse := func() {
			for i := range keys {
				(*obj)[keys[i]] = vals[i]
			}
		}
		var jv libjson.Value
		if *obj != nil {
			jv = libjson.NewMap(add, get, finishParse)
		}
		setNull := func(b bool) (libjson.Value, error) {
			if b {
				*obj = nil
				return nil, nil
			}
			*obj = ` + formatName(c, "raw", t) + `{}
			return libjson.NewMap(add, get, finishParse), nil
		}
		return libjson.NewNullable(jv, setNull), nil
		`
}

func (g *jsonGenerator) emitKeyToString(t *types.Type, c *generator.Context) string {
	// Map keys must be derived from string, encoding.TextMarshaler, or integral types.
	if hasTextMarshalMethod(t.Key) {
		glog.V(3).Infof("type %v has a MarshalText() method", t)
		g.imports.Add("fmt")
		return `
			keyToString := func(k ` + formatName(c, "raw", t.Key) + `) (string, error) {
				if b, err := k.MarshalText(); err != nil {
					return "", fmt.Errorf("failed %T.MarshalText: %v", k, err)
				} else {
					return string(b), nil
				}
			}
			`
	} else if rootType(t.Key) == types.String {
		return `
			keyToString := func(k ` + formatName(c, "raw", t.Key) + `) (string, error) {
				return string(k), nil
			}
			`
	} else {
		switch rootType(t.Key) {
		case types.Int, types.Int64, types.Int32, types.Int16, types.Int8:
			g.imports.Add("strconv")
			return `
				keyToString := func(k ` + formatName(c, "raw", t.Key) + `) (string, error) {
					return strconv.FormatInt(int64(k), 10), nil
				}
				`
		case types.Uint, types.Uint64, types.Uint32, types.Uint16, types.Uint8, types.Uintptr:
			g.imports.Add("strconv")
			return `
				keyToString := func(k ` + formatName(c, "raw", t.Key) + `) (string, error) {
					return strconv.FormatUint(uint64(k), 10), nil
				}
				`
		default:
			// If we hit this, the user really needs to know.
			panic("map key " + t.Key.String() + " is not string, int, uint, or encoding.TextMarshaler")
		}
	}
}

func (g *jsonGenerator) emitKeyFromString(t *types.Type, c *generator.Context) string {
	// Map keys must be derived from string, encoding.TextUnmarshaler, or integral types.
	if hasTextUnmarshalMethod(t.Key) {
		glog.V(3).Infof("type %v has an UnmarshalText() method", t)
		g.imports.Add("fmt")
		return `
			keyFromString := func(s string) (` + formatName(c, "raw", t.Key) + `, error) {
				var k ` + formatName(c, "raw", t.Key) + `
				if err := k.UnmarshalText([]byte(s)); err != nil {
					return k, fmt.Errorf("failed %T.UnmarshalText: %v", k, err)
				}
				return k, nil
			}
			`
	} else if rootType(t.Key) == types.String {
		return `
			keyFromString := func(s string) (` + formatName(c, "raw", t.Key) + `, error) {
				return ` + formatName(c, "raw", t.Key) + `(s), nil
			}
			`
	} else {
		switch rootType(t.Key) {
		case types.Int, types.Int64, types.Int32, types.Int16, types.Int8:
			g.imports.Add("strconv")
			return `
				keyFromString := func(s string) (` + formatName(c, "raw", t.Key) + `, error) {
					i, err := strconv.ParseInt(s, 10, 64)
					return ` + formatName(c, "raw", t.Key) + `(i), err
				}
				`
		case types.Uint, types.Uint64, types.Uint32, types.Uint16, types.Uint8, types.Uintptr:
			g.imports.Add("strconv")
			return `
				keyFromString := func(s string) (` + formatName(c, "raw", t.Key) + `, error) {
					i, err := strconv.ParseUint(s, 10, 64)
					return ` + formatName(c, "raw", t.Key) + `(i), err
				}
				`
		default:
			// If we hit this, the user really needs to know.
			panic("map key " + t.Key.String() + " is not string, int, uint, or encoding.TextUnmarshaler")
		}
	}
}

func (g *jsonGenerator) Finalize(c *generator.Context, w io.Writer) error {
	sw := generator.NewSnippetWriter(w, c, "$", "$")

	// loop because the list can be mutated while emitting
	for len(g.astNeeded) > 0 {
		todo := g.astNeeded
		g.astNeeded = nil
		glog.V(5).Infof("%d more types to emit", len(todo))
		for _, t := range todo {
			if g.astEmitted[t.String()] == true {
				continue
			}
			g.emitAST(t, c, sw)
		}
	}
	return sw.Error()
}

func (g *jsonGenerator) emitBodyForBuiltin(t *types.Type, c *generator.Context) string {
	switch t {
	case types.String:
		return `return libjson.NewString(func() string { return *obj }, func(s string) { *obj = s }), nil`
	case types.Bool:
		return `return libjson.NewBool(func() bool { return *obj }, func(b bool) { *obj = b }), nil`
	case types.Int, types.Int64, types.Int32, types.Int16, types.Int8:
		fallthrough
	case types.Uint, types.Uint64, types.Uint32, types.Uint16, types.Uint8, types.Uintptr, types.Byte:
		return `
			get := func() float64 {
				return float64(*obj)
			}
			set := func(f float64) {
				*obj = ` + formatName(c, "raw", t) + `(f)
			}
			return libjson.NewInt(get, set), nil
			`
	case types.Float64:
		return `
			get := func() float64 {
				return float64(*obj)
			}
			set := func(f float64) {
				*obj = ` + formatName(c, "raw", t) + `(f)
			}
			return libjson.NewFloat(64, get, set), nil
			`
	case types.Float32:
		return `
			get := func() float64 {
				return float64(*obj)
			}
			set := func(f float64) {
				*obj = ` + formatName(c, "raw", t) + `(f)
			}
			return libjson.NewFloat(32, get, set), nil
			`
	default:
		// This is a legit bug in the tool.
		panic("unknown builtin \"" + t.String() + "\"")
	}
}
