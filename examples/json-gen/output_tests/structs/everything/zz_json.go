// +build !ignore_autogenerated

/*
Copyright 2017 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// This file was autogenerated by json-gen. Do not edit it manually!

package test

import (
	bytes "bytes"
	libjson "k8s.io/gengo/examples/json-gen/libjson"
)

func ast__everything_Ttest(obj *Ttest) (libjson.Value, error) {

	result := libjson.Object{}

	// Byte byte
	{
		obj := &obj.Byte
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_byte((*byte)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Byte"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Byte was empty")
		} //FIXME:
	}

	// BytePtr *byte
	{
		obj := &obj.BytePtr
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_byte((**byte)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "BytePtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: BytePtr was empty")
		} //FIXME:
	}

	// ByteAlias k8s.io/gengo/examples/json-gen/./output_tests/structs/_everything.ByteAlias
	{
		obj := &obj.ByteAlias
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast__everything_ByteAlias((*ByteAlias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "ByteAlias"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: ByteAlias was empty")
		} //FIXME:
	}

	// ByteAliasPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/_everything.ByteAlias
	{
		obj := &obj.ByteAliasPtr
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer__everything_ByteAlias((**ByteAlias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "ByteAliasPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: ByteAliasPtr was empty")
		} //FIXME:
	}

	// Bool bool
	{
		obj := &obj.Bool
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_bool((*bool)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Bool"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Bool was empty")
		} //FIXME:
	}

	// BoolPtr *bool
	{
		obj := &obj.BoolPtr
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_bool((**bool)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "BoolPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: BoolPtr was empty")
		} //FIXME:
	}

	// BoolAlias k8s.io/gengo/examples/json-gen/./output_tests/structs/_everything.BoolAlias
	{
		obj := &obj.BoolAlias
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast__everything_BoolAlias((*BoolAlias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "BoolAlias"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: BoolAlias was empty")
		} //FIXME:
	}

	// BoolAliasPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/_everything.BoolAlias
	{
		obj := &obj.BoolAliasPtr
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer__everything_BoolAlias((**BoolAlias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "BoolAliasPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: BoolAliasPtr was empty")
		} //FIXME:
	}

	// Int8 int8
	{
		obj := &obj.Int8
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_int8((*int8)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Int8"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Int8 was empty")
		} //FIXME:
	}

	// Int8Ptr *int8
	{
		obj := &obj.Int8Ptr
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_int8((**int8)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Int8Ptr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Int8Ptr was empty")
		} //FIXME:
	}

	// Int16 int16
	{
		obj := &obj.Int16
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_int16((*int16)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Int16"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Int16 was empty")
		} //FIXME:
	}

	// Int16Ptr *int16
	{
		obj := &obj.Int16Ptr
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_int16((**int16)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Int16Ptr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Int16Ptr was empty")
		} //FIXME:
	}

	// Int32 int32
	{
		obj := &obj.Int32
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_int32((*int32)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Int32"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Int32 was empty")
		} //FIXME:
	}

	// Int32Ptr *int32
	{
		obj := &obj.Int32Ptr
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_int32((**int32)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Int32Ptr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Int32Ptr was empty")
		} //FIXME:
	}

	// Int32Alias k8s.io/gengo/examples/json-gen/./output_tests/structs/_everything.Int32Alias
	{
		obj := &obj.Int32Alias
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast__everything_Int32Alias((*Int32Alias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Int32Alias"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Int32Alias was empty")
		} //FIXME:
	}

	// Int32AliasPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/_everything.Int32Alias
	{
		obj := &obj.Int32AliasPtr
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer__everything_Int32Alias((**Int32Alias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Int32AliasPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Int32AliasPtr was empty")
		} //FIXME:
	}

	// Uint8 uint8
	{
		obj := &obj.Uint8
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_uint8((*uint8)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Uint8"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Uint8 was empty")
		} //FIXME:
	}

	// Uint8Ptr *uint8
	{
		obj := &obj.Uint8Ptr
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_uint8((**uint8)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Uint8Ptr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Uint8Ptr was empty")
		} //FIXME:
	}

	// Uint16 uint16
	{
		obj := &obj.Uint16
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_uint16((*uint16)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Uint16"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Uint16 was empty")
		} //FIXME:
	}

	// Uint16Ptr *uint16
	{
		obj := &obj.Uint16Ptr
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_uint16((**uint16)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Uint16Ptr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Uint16Ptr was empty")
		} //FIXME:
	}

	// Uint32 uint32
	{
		obj := &obj.Uint32
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_uint32((*uint32)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Uint32"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Uint32 was empty")
		} //FIXME:
	}

	// Uint32Ptr *uint32
	{
		obj := &obj.Uint32Ptr
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_uint32((**uint32)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Uint32Ptr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Uint32Ptr was empty")
		} //FIXME:
	}

	// Float32 float32
	{
		obj := &obj.Float32
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_float32((*float32)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Float32"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Float32 was empty")
		} //FIXME:
	}

	// Float32Ptr *float32
	{
		obj := &obj.Float32Ptr
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_float32((**float32)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Float32Ptr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Float32Ptr was empty")
		} //FIXME:
	}

	// Float32Alias k8s.io/gengo/examples/json-gen/./output_tests/structs/_everything.Float32Alias
	{
		obj := &obj.Float32Alias
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast__everything_Float32Alias((*Float32Alias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Float32Alias"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Float32Alias was empty")
		} //FIXME:
	}

	// Float32AliasPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/_everything.Float32Alias
	{
		obj := &obj.Float32AliasPtr
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer__everything_Float32Alias((**Float32Alias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Float32AliasPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Float32AliasPtr was empty")
		} //FIXME:
	}

	// Float64 float64
	{
		obj := &obj.Float64
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_float64((*float64)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Float64"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Float64 was empty")
		} //FIXME:
	}

	// Float64Ptr *float64
	{
		obj := &obj.Float64Ptr
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_float64((**float64)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Float64Ptr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Float64Ptr was empty")
		} //FIXME:
	}

	// String string
	{
		obj := &obj.String
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_string((*string)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "String"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: String was empty")
		} //FIXME:
	}

	// StringPtr *string
	{
		obj := &obj.StringPtr
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_string((**string)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "StringPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: StringPtr was empty")
		} //FIXME:
	}

	// StringAlias k8s.io/gengo/examples/json-gen/./output_tests/structs/_everything.StringAlias
	{
		obj := &obj.StringAlias
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast__everything_StringAlias((*StringAlias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "StringAlias"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: StringAlias was empty")
		} //FIXME:
	}

	// StringAliasPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/_everything.StringAlias
	{
		obj := &obj.StringAliasPtr
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer__everything_StringAlias((**StringAlias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "StringAliasPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: StringAliasPtr was empty")
		} //FIXME:
	}

	// StructPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/_everything.Inner
	{
		obj := &obj.StructPtr
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer__everything_Inner((**Inner)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "StructPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: StructPtr was empty")
		} //FIXME:
	}

	// Struct struct{Struct struct{Struct struct{Struct struct{String string}}}}
	{
		obj := &obj.Struct
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Struct_Struct_Struct_Struct_string((*struct {
			Struct struct {
				Struct struct{ Struct struct{ String string } }
			}
		})(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Struct"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Struct was empty")
		} //FIXME:
	}

	return result, nil

}

func (obj Ttest) MarshalJSON() ([]byte, error) {
	jv, err := ast__everything_Ttest(&obj)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	if err := jv.Render(&buf); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (obj *Ttest) UnmarshalJSON(data []byte) error {
	jv, err := ast__everything_Ttest(obj)
	if err != nil {
		return err
	}
	return jv.Parse(data)
}

func ast_byte(obj *byte) (libjson.Value, error) {

	get := func() float64 {
		return float64(*obj)
	}
	set := func(f float64) {
		*obj = byte(f)
	}
	return libjson.NewInt(get, set), nil

}

func ast_Pointer_byte(obj **byte) (libjson.Value, error) {

	{
		p := obj
		obj := *obj
		if obj == nil {
			obj = new(byte)
		}
		jv, err := ast_byte((*byte)(obj))
		if err != nil {
			return nil, err
		}
		setNull := func(b bool) {
			if b {
				*p = nil
			} else {
				*p = obj
			}
		}
		return libjson.NewNullable(jv, *p == nil, setNull), nil
	}

}

func ast__everything_ByteAlias(obj *ByteAlias) (libjson.Value, error) {
	return ast_byte((*byte)(obj))
}

func ast_Pointer__everything_ByteAlias(obj **ByteAlias) (libjson.Value, error) {

	{
		p := obj
		obj := *obj
		if obj == nil {
			obj = new(ByteAlias)
		}
		jv, err := ast__everything_ByteAlias((*ByteAlias)(obj))
		if err != nil {
			return nil, err
		}
		setNull := func(b bool) {
			if b {
				*p = nil
			} else {
				*p = obj
			}
		}
		return libjson.NewNullable(jv, *p == nil, setNull), nil
	}

}

func ast_bool(obj *bool) (libjson.Value, error) {
	return libjson.NewBool(func() bool { return *obj }, func(b bool) { *obj = b }), nil
}

func ast_Pointer_bool(obj **bool) (libjson.Value, error) {

	{
		p := obj
		obj := *obj
		if obj == nil {
			obj = new(bool)
		}
		jv, err := ast_bool((*bool)(obj))
		if err != nil {
			return nil, err
		}
		setNull := func(b bool) {
			if b {
				*p = nil
			} else {
				*p = obj
			}
		}
		return libjson.NewNullable(jv, *p == nil, setNull), nil
	}

}

func ast__everything_BoolAlias(obj *BoolAlias) (libjson.Value, error) {
	return ast_bool((*bool)(obj))
}

func ast_Pointer__everything_BoolAlias(obj **BoolAlias) (libjson.Value, error) {

	{
		p := obj
		obj := *obj
		if obj == nil {
			obj = new(BoolAlias)
		}
		jv, err := ast__everything_BoolAlias((*BoolAlias)(obj))
		if err != nil {
			return nil, err
		}
		setNull := func(b bool) {
			if b {
				*p = nil
			} else {
				*p = obj
			}
		}
		return libjson.NewNullable(jv, *p == nil, setNull), nil
	}

}

func ast_int8(obj *int8) (libjson.Value, error) {

	get := func() float64 {
		return float64(*obj)
	}
	set := func(f float64) {
		*obj = int8(f)
	}
	return libjson.NewInt(get, set), nil

}

func ast_Pointer_int8(obj **int8) (libjson.Value, error) {

	{
		p := obj
		obj := *obj
		if obj == nil {
			obj = new(int8)
		}
		jv, err := ast_int8((*int8)(obj))
		if err != nil {
			return nil, err
		}
		setNull := func(b bool) {
			if b {
				*p = nil
			} else {
				*p = obj
			}
		}
		return libjson.NewNullable(jv, *p == nil, setNull), nil
	}

}

func ast_int16(obj *int16) (libjson.Value, error) {

	get := func() float64 {
		return float64(*obj)
	}
	set := func(f float64) {
		*obj = int16(f)
	}
	return libjson.NewInt(get, set), nil

}

func ast_Pointer_int16(obj **int16) (libjson.Value, error) {

	{
		p := obj
		obj := *obj
		if obj == nil {
			obj = new(int16)
		}
		jv, err := ast_int16((*int16)(obj))
		if err != nil {
			return nil, err
		}
		setNull := func(b bool) {
			if b {
				*p = nil
			} else {
				*p = obj
			}
		}
		return libjson.NewNullable(jv, *p == nil, setNull), nil
	}

}

func ast_int32(obj *int32) (libjson.Value, error) {

	get := func() float64 {
		return float64(*obj)
	}
	set := func(f float64) {
		*obj = int32(f)
	}
	return libjson.NewInt(get, set), nil

}

func ast_Pointer_int32(obj **int32) (libjson.Value, error) {

	{
		p := obj
		obj := *obj
		if obj == nil {
			obj = new(int32)
		}
		jv, err := ast_int32((*int32)(obj))
		if err != nil {
			return nil, err
		}
		setNull := func(b bool) {
			if b {
				*p = nil
			} else {
				*p = obj
			}
		}
		return libjson.NewNullable(jv, *p == nil, setNull), nil
	}

}

func ast__everything_Int32Alias(obj *Int32Alias) (libjson.Value, error) {
	return ast_int32((*int32)(obj))
}

func ast_Pointer__everything_Int32Alias(obj **Int32Alias) (libjson.Value, error) {

	{
		p := obj
		obj := *obj
		if obj == nil {
			obj = new(Int32Alias)
		}
		jv, err := ast__everything_Int32Alias((*Int32Alias)(obj))
		if err != nil {
			return nil, err
		}
		setNull := func(b bool) {
			if b {
				*p = nil
			} else {
				*p = obj
			}
		}
		return libjson.NewNullable(jv, *p == nil, setNull), nil
	}

}

func ast_uint8(obj *uint8) (libjson.Value, error) {

	get := func() float64 {
		return float64(*obj)
	}
	set := func(f float64) {
		*obj = uint8(f)
	}
	return libjson.NewInt(get, set), nil

}

func ast_Pointer_uint8(obj **uint8) (libjson.Value, error) {

	{
		p := obj
		obj := *obj
		if obj == nil {
			obj = new(uint8)
		}
		jv, err := ast_uint8((*uint8)(obj))
		if err != nil {
			return nil, err
		}
		setNull := func(b bool) {
			if b {
				*p = nil
			} else {
				*p = obj
			}
		}
		return libjson.NewNullable(jv, *p == nil, setNull), nil
	}

}

func ast_uint16(obj *uint16) (libjson.Value, error) {

	get := func() float64 {
		return float64(*obj)
	}
	set := func(f float64) {
		*obj = uint16(f)
	}
	return libjson.NewInt(get, set), nil

}

func ast_Pointer_uint16(obj **uint16) (libjson.Value, error) {

	{
		p := obj
		obj := *obj
		if obj == nil {
			obj = new(uint16)
		}
		jv, err := ast_uint16((*uint16)(obj))
		if err != nil {
			return nil, err
		}
		setNull := func(b bool) {
			if b {
				*p = nil
			} else {
				*p = obj
			}
		}
		return libjson.NewNullable(jv, *p == nil, setNull), nil
	}

}

func ast_uint32(obj *uint32) (libjson.Value, error) {

	get := func() float64 {
		return float64(*obj)
	}
	set := func(f float64) {
		*obj = uint32(f)
	}
	return libjson.NewInt(get, set), nil

}

func ast_Pointer_uint32(obj **uint32) (libjson.Value, error) {

	{
		p := obj
		obj := *obj
		if obj == nil {
			obj = new(uint32)
		}
		jv, err := ast_uint32((*uint32)(obj))
		if err != nil {
			return nil, err
		}
		setNull := func(b bool) {
			if b {
				*p = nil
			} else {
				*p = obj
			}
		}
		return libjson.NewNullable(jv, *p == nil, setNull), nil
	}

}

func ast_float32(obj *float32) (libjson.Value, error) {

	get := func() float64 {
		return float64(*obj)
	}
	set := func(f float64) {
		*obj = float32(f)
	}
	return libjson.NewFloat(32, get, set), nil

}

func ast_Pointer_float32(obj **float32) (libjson.Value, error) {

	{
		p := obj
		obj := *obj
		if obj == nil {
			obj = new(float32)
		}
		jv, err := ast_float32((*float32)(obj))
		if err != nil {
			return nil, err
		}
		setNull := func(b bool) {
			if b {
				*p = nil
			} else {
				*p = obj
			}
		}
		return libjson.NewNullable(jv, *p == nil, setNull), nil
	}

}

func ast__everything_Float32Alias(obj *Float32Alias) (libjson.Value, error) {
	return ast_float32((*float32)(obj))
}

func ast_Pointer__everything_Float32Alias(obj **Float32Alias) (libjson.Value, error) {

	{
		p := obj
		obj := *obj
		if obj == nil {
			obj = new(Float32Alias)
		}
		jv, err := ast__everything_Float32Alias((*Float32Alias)(obj))
		if err != nil {
			return nil, err
		}
		setNull := func(b bool) {
			if b {
				*p = nil
			} else {
				*p = obj
			}
		}
		return libjson.NewNullable(jv, *p == nil, setNull), nil
	}

}

func ast_float64(obj *float64) (libjson.Value, error) {

	get := func() float64 {
		return float64(*obj)
	}
	set := func(f float64) {
		*obj = float64(f)
	}
	return libjson.NewFloat(64, get, set), nil

}

func ast_Pointer_float64(obj **float64) (libjson.Value, error) {

	{
		p := obj
		obj := *obj
		if obj == nil {
			obj = new(float64)
		}
		jv, err := ast_float64((*float64)(obj))
		if err != nil {
			return nil, err
		}
		setNull := func(b bool) {
			if b {
				*p = nil
			} else {
				*p = obj
			}
		}
		return libjson.NewNullable(jv, *p == nil, setNull), nil
	}

}

func ast_string(obj *string) (libjson.Value, error) {
	return libjson.NewString(func() string { return *obj }, func(s string) { *obj = s }), nil
}

func ast_Pointer_string(obj **string) (libjson.Value, error) {

	{
		p := obj
		obj := *obj
		if obj == nil {
			obj = new(string)
		}
		jv, err := ast_string((*string)(obj))
		if err != nil {
			return nil, err
		}
		setNull := func(b bool) {
			if b {
				*p = nil
			} else {
				*p = obj
			}
		}
		return libjson.NewNullable(jv, *p == nil, setNull), nil
	}

}

func ast__everything_StringAlias(obj *StringAlias) (libjson.Value, error) {
	return ast_string((*string)(obj))
}

func ast_Pointer__everything_StringAlias(obj **StringAlias) (libjson.Value, error) {

	{
		p := obj
		obj := *obj
		if obj == nil {
			obj = new(StringAlias)
		}
		jv, err := ast__everything_StringAlias((*StringAlias)(obj))
		if err != nil {
			return nil, err
		}
		setNull := func(b bool) {
			if b {
				*p = nil
			} else {
				*p = obj
			}
		}
		return libjson.NewNullable(jv, *p == nil, setNull), nil
	}

}

func ast_Pointer__everything_Inner(obj **Inner) (libjson.Value, error) {

	{
		p := obj
		obj := *obj
		if obj == nil {
			obj = new(Inner)
		}
		jv, err := ast__everything_Inner((*Inner)(obj))
		if err != nil {
			return nil, err
		}
		setNull := func(b bool) {
			if b {
				*p = nil
			} else {
				*p = obj
			}
		}
		return libjson.NewNullable(jv, *p == nil, setNull), nil
	}

}

func ast_Struct_Struct_Struct_Struct_string(obj *struct {
	Struct struct {
		Struct struct{ Struct struct{ String string } }
	}
}) (libjson.Value, error) {

	result := libjson.Object{}

	// Struct struct{Struct struct{Struct struct{String string}}}
	{
		obj := &obj.Struct
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Struct_Struct_Struct_string((*struct {
			Struct struct{ Struct struct{ String string } }
		})(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Struct"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Struct was empty")
		} //FIXME:
	}

	return result, nil

}

func ast__everything_Inner(obj *Inner) (libjson.Value, error) {

	result := libjson.Object{}

	// Byte byte
	{
		obj := &obj.Byte
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_byte((*byte)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Byte"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Byte was empty")
		} //FIXME:
	}

	// BytePtr *byte
	{
		obj := &obj.BytePtr
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_byte((**byte)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "BytePtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: BytePtr was empty")
		} //FIXME:
	}

	// ByteAlias k8s.io/gengo/examples/json-gen/./output_tests/structs/_everything.ByteAlias
	{
		obj := &obj.ByteAlias
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast__everything_ByteAlias((*ByteAlias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "ByteAlias"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: ByteAlias was empty")
		} //FIXME:
	}

	// ByteAliasPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/_everything.ByteAlias
	{
		obj := &obj.ByteAliasPtr
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer__everything_ByteAlias((**ByteAlias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "ByteAliasPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: ByteAliasPtr was empty")
		} //FIXME:
	}

	// Bool bool
	{
		obj := &obj.Bool
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_bool((*bool)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Bool"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Bool was empty")
		} //FIXME:
	}

	// BoolPtr *bool
	{
		obj := &obj.BoolPtr
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_bool((**bool)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "BoolPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: BoolPtr was empty")
		} //FIXME:
	}

	// BoolAlias k8s.io/gengo/examples/json-gen/./output_tests/structs/_everything.BoolAlias
	{
		obj := &obj.BoolAlias
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast__everything_BoolAlias((*BoolAlias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "BoolAlias"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: BoolAlias was empty")
		} //FIXME:
	}

	// BoolAliasPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/_everything.BoolAlias
	{
		obj := &obj.BoolAliasPtr
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer__everything_BoolAlias((**BoolAlias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "BoolAliasPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: BoolAliasPtr was empty")
		} //FIXME:
	}

	// Int8 int8
	{
		obj := &obj.Int8
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_int8((*int8)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Int8"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Int8 was empty")
		} //FIXME:
	}

	// Int8Ptr *int8
	{
		obj := &obj.Int8Ptr
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_int8((**int8)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Int8Ptr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Int8Ptr was empty")
		} //FIXME:
	}

	// Int16 int16
	{
		obj := &obj.Int16
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_int16((*int16)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Int16"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Int16 was empty")
		} //FIXME:
	}

	// Int16Ptr *int16
	{
		obj := &obj.Int16Ptr
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_int16((**int16)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Int16Ptr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Int16Ptr was empty")
		} //FIXME:
	}

	// Int32 int32
	{
		obj := &obj.Int32
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_int32((*int32)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Int32"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Int32 was empty")
		} //FIXME:
	}

	// Int32Ptr *int32
	{
		obj := &obj.Int32Ptr
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_int32((**int32)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Int32Ptr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Int32Ptr was empty")
		} //FIXME:
	}

	// Int32Alias k8s.io/gengo/examples/json-gen/./output_tests/structs/_everything.Int32Alias
	{
		obj := &obj.Int32Alias
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast__everything_Int32Alias((*Int32Alias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Int32Alias"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Int32Alias was empty")
		} //FIXME:
	}

	// Int32AliasPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/_everything.Int32Alias
	{
		obj := &obj.Int32AliasPtr
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer__everything_Int32Alias((**Int32Alias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Int32AliasPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Int32AliasPtr was empty")
		} //FIXME:
	}

	// Uint8 uint8
	{
		obj := &obj.Uint8
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_uint8((*uint8)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Uint8"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Uint8 was empty")
		} //FIXME:
	}

	// Uint8Ptr *uint8
	{
		obj := &obj.Uint8Ptr
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_uint8((**uint8)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Uint8Ptr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Uint8Ptr was empty")
		} //FIXME:
	}

	// Uint16 uint16
	{
		obj := &obj.Uint16
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_uint16((*uint16)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Uint16"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Uint16 was empty")
		} //FIXME:
	}

	// Uint16Ptr *uint16
	{
		obj := &obj.Uint16Ptr
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_uint16((**uint16)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Uint16Ptr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Uint16Ptr was empty")
		} //FIXME:
	}

	// Uint32 uint32
	{
		obj := &obj.Uint32
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_uint32((*uint32)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Uint32"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Uint32 was empty")
		} //FIXME:
	}

	// Uint32Ptr *uint32
	{
		obj := &obj.Uint32Ptr
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_uint32((**uint32)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Uint32Ptr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Uint32Ptr was empty")
		} //FIXME:
	}

	// Float32 float32
	{
		obj := &obj.Float32
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_float32((*float32)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Float32"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Float32 was empty")
		} //FIXME:
	}

	// Float32Ptr *float32
	{
		obj := &obj.Float32Ptr
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_float32((**float32)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Float32Ptr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Float32Ptr was empty")
		} //FIXME:
	}

	// Float32Alias k8s.io/gengo/examples/json-gen/./output_tests/structs/_everything.Float32Alias
	{
		obj := &obj.Float32Alias
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast__everything_Float32Alias((*Float32Alias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Float32Alias"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Float32Alias was empty")
		} //FIXME:
	}

	// Float32AliasPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/_everything.Float32Alias
	{
		obj := &obj.Float32AliasPtr
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer__everything_Float32Alias((**Float32Alias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Float32AliasPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Float32AliasPtr was empty")
		} //FIXME:
	}

	// Float64 float64
	{
		obj := &obj.Float64
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_float64((*float64)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Float64"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Float64 was empty")
		} //FIXME:
	}

	// Float64Ptr *float64
	{
		obj := &obj.Float64Ptr
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_float64((**float64)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Float64Ptr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Float64Ptr was empty")
		} //FIXME:
	}

	// String string
	{
		obj := &obj.String
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_string((*string)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "String"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: String was empty")
		} //FIXME:
	}

	// StringPtr *string
	{
		obj := &obj.StringPtr
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_string((**string)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "StringPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: StringPtr was empty")
		} //FIXME:
	}

	// StringAlias k8s.io/gengo/examples/json-gen/./output_tests/structs/_everything.StringAlias
	{
		obj := &obj.StringAlias
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast__everything_StringAlias((*StringAlias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "StringAlias"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: StringAlias was empty")
		} //FIXME:
	}

	// StringAliasPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/_everything.StringAlias
	{
		obj := &obj.StringAliasPtr
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer__everything_StringAlias((**StringAlias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "StringAliasPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: StringAliasPtr was empty")
		} //FIXME:
	}

	// Struct struct{Byte byte; BytePtr *byte; ByteAlias k8s.io/gengo/examples/json-gen/./output_tests/structs/_everything.ByteAlias; ByteAliasPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/_everything.ByteAlias; Bool bool; BoolPtr *bool; BoolAlias k8s.io/gengo/examples/json-gen/./output_tests/structs/_everything.BoolAlias; BoolAliasPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/_everything.BoolAlias; Int8 int8; Int8Ptr *int8; Int16 int16; Int16Ptr *int16; Int32 int32; Int32Ptr *int32; Int32Alias k8s.io/gengo/examples/json-gen/./output_tests/structs/_everything.Int32Alias; Int32AliasPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/_everything.Int32Alias; Uint8 uint8; Uint8Ptr *uint8; Uint16 uint16; Uint16Ptr *uint16; Uint32 uint32; Uint32Ptr *uint32; Float32 float32; Float32Ptr *float32; Float32Alias k8s.io/gengo/examples/json-gen/./output_tests/structs/_everything.Float32Alias; Float32AliasPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/_everything.Float32Alias; Float64 float64; Float64Ptr *float64; String string; StringPtr *string; StringAlias k8s.io/gengo/examples/json-gen/./output_tests/structs/_everything.StringAlias; StringAliasPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/_everything.StringAlias; Struct struct{}; StructPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/_everything.Inner}
	{
		obj := &obj.Struct
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Struct_byte_Pointer_byte__everything_ByteAlias_Pointer__everything_ByteAlias_bool_Pointer_bool__everything_BoolAlias_Pointer__everything_BoolAlias_int8_Pointer_int8_int16_Pointer_int16_int32_Pointer_int32__everything_Int32Alias_Pointer__everything_Int32Alias_uint8_Pointer_uint8_uint16_Pointer_uint16_uint32_Pointer_uint32_float32_Pointer_float32__everything_Float32Alias_Pointer__everything_Float32Alias_float64_Pointer_float64_string_Pointer_string__everything_StringAlias_Pointer__everything_StringAlias_Struct_Pointer__everything_Inner((*struct {
			Byte            byte
			BytePtr         *byte
			ByteAlias       ByteAlias
			ByteAliasPtr    *ByteAlias
			Bool            bool
			BoolPtr         *bool
			BoolAlias       BoolAlias
			BoolAliasPtr    *BoolAlias
			Int8            int8
			Int8Ptr         *int8
			Int16           int16
			Int16Ptr        *int16
			Int32           int32
			Int32Ptr        *int32
			Int32Alias      Int32Alias
			Int32AliasPtr   *Int32Alias
			Uint8           uint8
			Uint8Ptr        *uint8
			Uint16          uint16
			Uint16Ptr       *uint16
			Uint32          uint32
			Uint32Ptr       *uint32
			Float32         float32
			Float32Ptr      *float32
			Float32Alias    Float32Alias
			Float32AliasPtr *Float32Alias
			Float64         float64
			Float64Ptr      *float64
			String          string
			StringPtr       *string
			StringAlias     StringAlias
			StringAliasPtr  *StringAlias
			Struct          struct{}
			StructPtr       *Inner
		})(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Struct"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Struct was empty")
		} //FIXME:
	}

	// StructPtr *struct{Byte byte; BytePtr *byte; ByteAlias k8s.io/gengo/examples/json-gen/./output_tests/structs/_everything.ByteAlias; ByteAliasPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/_everything.ByteAlias; Bool bool; BoolPtr *bool; BoolAlias k8s.io/gengo/examples/json-gen/./output_tests/structs/_everything.BoolAlias; BoolAliasPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/_everything.BoolAlias; Int8 int8; Int8Ptr *int8; Int16 int16; Int16Ptr *int16; Int32 int32; Int32Ptr *int32; Int32Alias k8s.io/gengo/examples/json-gen/./output_tests/structs/_everything.Int32Alias; Int32AliasPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/_everything.Int32Alias; Uint8 uint8; Uint8Ptr *uint8; Uint16 uint16; Uint16Ptr *uint16; Uint32 uint32; Uint32Ptr *uint32; Float32 float32; Float32Ptr *float32; Float32Alias k8s.io/gengo/examples/json-gen/./output_tests/structs/_everything.Float32Alias; Float32AliasPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/_everything.Float32Alias; Float64 float64; Float64Ptr *float64; String string; StringPtr *string; StringAlias k8s.io/gengo/examples/json-gen/./output_tests/structs/_everything.StringAlias; StringAliasPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/_everything.StringAlias; Struct struct{}; StructPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/_everything.Inner}
	{
		obj := &obj.StructPtr
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_Struct_byte_Pointer_byte__everything_ByteAlias_Pointer__everything_ByteAlias_bool_Pointer_bool__everything_BoolAlias_Pointer__everything_BoolAlias_int8_Pointer_int8_int16_Pointer_int16_int32_Pointer_int32__everything_Int32Alias_Pointer__everything_Int32Alias_uint8_Pointer_uint8_uint16_Pointer_uint16_uint32_Pointer_uint32_float32_Pointer_float32__everything_Float32Alias_Pointer__everything_Float32Alias_float64_Pointer_float64_string_Pointer_string__everything_StringAlias_Pointer__everything_StringAlias_Struct_Pointer__everything_Inner((**struct {
			Byte            byte
			BytePtr         *byte
			ByteAlias       ByteAlias
			ByteAliasPtr    *ByteAlias
			Bool            bool
			BoolPtr         *bool
			BoolAlias       BoolAlias
			BoolAliasPtr    *BoolAlias
			Int8            int8
			Int8Ptr         *int8
			Int16           int16
			Int16Ptr        *int16
			Int32           int32
			Int32Ptr        *int32
			Int32Alias      Int32Alias
			Int32AliasPtr   *Int32Alias
			Uint8           uint8
			Uint8Ptr        *uint8
			Uint16          uint16
			Uint16Ptr       *uint16
			Uint32          uint32
			Uint32Ptr       *uint32
			Float32         float32
			Float32Ptr      *float32
			Float32Alias    Float32Alias
			Float32AliasPtr *Float32Alias
			Float64         float64
			Float64Ptr      *float64
			String          string
			StringPtr       *string
			StringAlias     StringAlias
			StringAliasPtr  *StringAlias
			Struct          struct{}
			StructPtr       *Inner
		})(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "StructPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: StructPtr was empty")
		} //FIXME:
	}

	return result, nil

}

func ast_Struct_Struct_Struct_string(obj *struct {
	Struct struct{ Struct struct{ String string } }
}) (libjson.Value, error) {

	result := libjson.Object{}

	// Struct struct{Struct struct{String string}}
	{
		obj := &obj.Struct
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Struct_Struct_string((*struct{ Struct struct{ String string } })(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Struct"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Struct was empty")
		} //FIXME:
	}

	return result, nil

}

func ast_Struct_byte_Pointer_byte__everything_ByteAlias_Pointer__everything_ByteAlias_bool_Pointer_bool__everything_BoolAlias_Pointer__everything_BoolAlias_int8_Pointer_int8_int16_Pointer_int16_int32_Pointer_int32__everything_Int32Alias_Pointer__everything_Int32Alias_uint8_Pointer_uint8_uint16_Pointer_uint16_uint32_Pointer_uint32_float32_Pointer_float32__everything_Float32Alias_Pointer__everything_Float32Alias_float64_Pointer_float64_string_Pointer_string__everything_StringAlias_Pointer__everything_StringAlias_Struct_Pointer__everything_Inner(obj *struct {
	Byte            byte
	BytePtr         *byte
	ByteAlias       ByteAlias
	ByteAliasPtr    *ByteAlias
	Bool            bool
	BoolPtr         *bool
	BoolAlias       BoolAlias
	BoolAliasPtr    *BoolAlias
	Int8            int8
	Int8Ptr         *int8
	Int16           int16
	Int16Ptr        *int16
	Int32           int32
	Int32Ptr        *int32
	Int32Alias      Int32Alias
	Int32AliasPtr   *Int32Alias
	Uint8           uint8
	Uint8Ptr        *uint8
	Uint16          uint16
	Uint16Ptr       *uint16
	Uint32          uint32
	Uint32Ptr       *uint32
	Float32         float32
	Float32Ptr      *float32
	Float32Alias    Float32Alias
	Float32AliasPtr *Float32Alias
	Float64         float64
	Float64Ptr      *float64
	String          string
	StringPtr       *string
	StringAlias     StringAlias
	StringAliasPtr  *StringAlias
	Struct          struct{}
	StructPtr       *Inner
}) (libjson.Value, error) {

	result := libjson.Object{}

	// Byte byte
	{
		obj := &obj.Byte
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_byte((*byte)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Byte"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Byte was empty")
		} //FIXME:
	}

	// BytePtr *byte
	{
		obj := &obj.BytePtr
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_byte((**byte)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "BytePtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: BytePtr was empty")
		} //FIXME:
	}

	// ByteAlias k8s.io/gengo/examples/json-gen/./output_tests/structs/_everything.ByteAlias
	{
		obj := &obj.ByteAlias
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast__everything_ByteAlias((*ByteAlias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "ByteAlias"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: ByteAlias was empty")
		} //FIXME:
	}

	// ByteAliasPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/_everything.ByteAlias
	{
		obj := &obj.ByteAliasPtr
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer__everything_ByteAlias((**ByteAlias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "ByteAliasPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: ByteAliasPtr was empty")
		} //FIXME:
	}

	// Bool bool
	{
		obj := &obj.Bool
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_bool((*bool)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Bool"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Bool was empty")
		} //FIXME:
	}

	// BoolPtr *bool
	{
		obj := &obj.BoolPtr
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_bool((**bool)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "BoolPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: BoolPtr was empty")
		} //FIXME:
	}

	// BoolAlias k8s.io/gengo/examples/json-gen/./output_tests/structs/_everything.BoolAlias
	{
		obj := &obj.BoolAlias
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast__everything_BoolAlias((*BoolAlias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "BoolAlias"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: BoolAlias was empty")
		} //FIXME:
	}

	// BoolAliasPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/_everything.BoolAlias
	{
		obj := &obj.BoolAliasPtr
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer__everything_BoolAlias((**BoolAlias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "BoolAliasPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: BoolAliasPtr was empty")
		} //FIXME:
	}

	// Int8 int8
	{
		obj := &obj.Int8
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_int8((*int8)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Int8"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Int8 was empty")
		} //FIXME:
	}

	// Int8Ptr *int8
	{
		obj := &obj.Int8Ptr
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_int8((**int8)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Int8Ptr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Int8Ptr was empty")
		} //FIXME:
	}

	// Int16 int16
	{
		obj := &obj.Int16
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_int16((*int16)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Int16"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Int16 was empty")
		} //FIXME:
	}

	// Int16Ptr *int16
	{
		obj := &obj.Int16Ptr
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_int16((**int16)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Int16Ptr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Int16Ptr was empty")
		} //FIXME:
	}

	// Int32 int32
	{
		obj := &obj.Int32
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_int32((*int32)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Int32"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Int32 was empty")
		} //FIXME:
	}

	// Int32Ptr *int32
	{
		obj := &obj.Int32Ptr
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_int32((**int32)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Int32Ptr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Int32Ptr was empty")
		} //FIXME:
	}

	// Int32Alias k8s.io/gengo/examples/json-gen/./output_tests/structs/_everything.Int32Alias
	{
		obj := &obj.Int32Alias
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast__everything_Int32Alias((*Int32Alias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Int32Alias"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Int32Alias was empty")
		} //FIXME:
	}

	// Int32AliasPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/_everything.Int32Alias
	{
		obj := &obj.Int32AliasPtr
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer__everything_Int32Alias((**Int32Alias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Int32AliasPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Int32AliasPtr was empty")
		} //FIXME:
	}

	// Uint8 uint8
	{
		obj := &obj.Uint8
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_uint8((*uint8)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Uint8"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Uint8 was empty")
		} //FIXME:
	}

	// Uint8Ptr *uint8
	{
		obj := &obj.Uint8Ptr
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_uint8((**uint8)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Uint8Ptr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Uint8Ptr was empty")
		} //FIXME:
	}

	// Uint16 uint16
	{
		obj := &obj.Uint16
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_uint16((*uint16)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Uint16"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Uint16 was empty")
		} //FIXME:
	}

	// Uint16Ptr *uint16
	{
		obj := &obj.Uint16Ptr
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_uint16((**uint16)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Uint16Ptr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Uint16Ptr was empty")
		} //FIXME:
	}

	// Uint32 uint32
	{
		obj := &obj.Uint32
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_uint32((*uint32)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Uint32"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Uint32 was empty")
		} //FIXME:
	}

	// Uint32Ptr *uint32
	{
		obj := &obj.Uint32Ptr
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_uint32((**uint32)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Uint32Ptr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Uint32Ptr was empty")
		} //FIXME:
	}

	// Float32 float32
	{
		obj := &obj.Float32
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_float32((*float32)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Float32"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Float32 was empty")
		} //FIXME:
	}

	// Float32Ptr *float32
	{
		obj := &obj.Float32Ptr
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_float32((**float32)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Float32Ptr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Float32Ptr was empty")
		} //FIXME:
	}

	// Float32Alias k8s.io/gengo/examples/json-gen/./output_tests/structs/_everything.Float32Alias
	{
		obj := &obj.Float32Alias
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast__everything_Float32Alias((*Float32Alias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Float32Alias"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Float32Alias was empty")
		} //FIXME:
	}

	// Float32AliasPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/_everything.Float32Alias
	{
		obj := &obj.Float32AliasPtr
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer__everything_Float32Alias((**Float32Alias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Float32AliasPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Float32AliasPtr was empty")
		} //FIXME:
	}

	// Float64 float64
	{
		obj := &obj.Float64
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_float64((*float64)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Float64"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Float64 was empty")
		} //FIXME:
	}

	// Float64Ptr *float64
	{
		obj := &obj.Float64Ptr
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_float64((**float64)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Float64Ptr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Float64Ptr was empty")
		} //FIXME:
	}

	// String string
	{
		obj := &obj.String
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_string((*string)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "String"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: String was empty")
		} //FIXME:
	}

	// StringPtr *string
	{
		obj := &obj.StringPtr
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_string((**string)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "StringPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: StringPtr was empty")
		} //FIXME:
	}

	// StringAlias k8s.io/gengo/examples/json-gen/./output_tests/structs/_everything.StringAlias
	{
		obj := &obj.StringAlias
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast__everything_StringAlias((*StringAlias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "StringAlias"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: StringAlias was empty")
		} //FIXME:
	}

	// StringAliasPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/_everything.StringAlias
	{
		obj := &obj.StringAliasPtr
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer__everything_StringAlias((**StringAlias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "StringAliasPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: StringAliasPtr was empty")
		} //FIXME:
	}

	// Struct struct{}
	{
		obj := &obj.Struct
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Struct((*struct{})(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Struct"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Struct was empty")
		} //FIXME:
	}

	// StructPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/_everything.Inner
	{
		obj := &obj.StructPtr
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer__everything_Inner((**Inner)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "StructPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: StructPtr was empty")
		} //FIXME:
	}

	return result, nil

}

func ast_Pointer_Struct_byte_Pointer_byte__everything_ByteAlias_Pointer__everything_ByteAlias_bool_Pointer_bool__everything_BoolAlias_Pointer__everything_BoolAlias_int8_Pointer_int8_int16_Pointer_int16_int32_Pointer_int32__everything_Int32Alias_Pointer__everything_Int32Alias_uint8_Pointer_uint8_uint16_Pointer_uint16_uint32_Pointer_uint32_float32_Pointer_float32__everything_Float32Alias_Pointer__everything_Float32Alias_float64_Pointer_float64_string_Pointer_string__everything_StringAlias_Pointer__everything_StringAlias_Struct_Pointer__everything_Inner(obj **struct {
	Byte            byte
	BytePtr         *byte
	ByteAlias       ByteAlias
	ByteAliasPtr    *ByteAlias
	Bool            bool
	BoolPtr         *bool
	BoolAlias       BoolAlias
	BoolAliasPtr    *BoolAlias
	Int8            int8
	Int8Ptr         *int8
	Int16           int16
	Int16Ptr        *int16
	Int32           int32
	Int32Ptr        *int32
	Int32Alias      Int32Alias
	Int32AliasPtr   *Int32Alias
	Uint8           uint8
	Uint8Ptr        *uint8
	Uint16          uint16
	Uint16Ptr       *uint16
	Uint32          uint32
	Uint32Ptr       *uint32
	Float32         float32
	Float32Ptr      *float32
	Float32Alias    Float32Alias
	Float32AliasPtr *Float32Alias
	Float64         float64
	Float64Ptr      *float64
	String          string
	StringPtr       *string
	StringAlias     StringAlias
	StringAliasPtr  *StringAlias
	Struct          struct{}
	StructPtr       *Inner
}) (libjson.Value, error) {

	{
		p := obj
		obj := *obj
		if obj == nil {
			obj = new(struct {
				Byte            byte
				BytePtr         *byte
				ByteAlias       ByteAlias
				ByteAliasPtr    *ByteAlias
				Bool            bool
				BoolPtr         *bool
				BoolAlias       BoolAlias
				BoolAliasPtr    *BoolAlias
				Int8            int8
				Int8Ptr         *int8
				Int16           int16
				Int16Ptr        *int16
				Int32           int32
				Int32Ptr        *int32
				Int32Alias      Int32Alias
				Int32AliasPtr   *Int32Alias
				Uint8           uint8
				Uint8Ptr        *uint8
				Uint16          uint16
				Uint16Ptr       *uint16
				Uint32          uint32
				Uint32Ptr       *uint32
				Float32         float32
				Float32Ptr      *float32
				Float32Alias    Float32Alias
				Float32AliasPtr *Float32Alias
				Float64         float64
				Float64Ptr      *float64
				String          string
				StringPtr       *string
				StringAlias     StringAlias
				StringAliasPtr  *StringAlias
				Struct          struct{}
				StructPtr       *Inner
			})
		}
		jv, err := ast_Struct_byte_Pointer_byte__everything_ByteAlias_Pointer__everything_ByteAlias_bool_Pointer_bool__everything_BoolAlias_Pointer__everything_BoolAlias_int8_Pointer_int8_int16_Pointer_int16_int32_Pointer_int32__everything_Int32Alias_Pointer__everything_Int32Alias_uint8_Pointer_uint8_uint16_Pointer_uint16_uint32_Pointer_uint32_float32_Pointer_float32__everything_Float32Alias_Pointer__everything_Float32Alias_float64_Pointer_float64_string_Pointer_string__everything_StringAlias_Pointer__everything_StringAlias_Struct_Pointer__everything_Inner((*struct {
			Byte            byte
			BytePtr         *byte
			ByteAlias       ByteAlias
			ByteAliasPtr    *ByteAlias
			Bool            bool
			BoolPtr         *bool
			BoolAlias       BoolAlias
			BoolAliasPtr    *BoolAlias
			Int8            int8
			Int8Ptr         *int8
			Int16           int16
			Int16Ptr        *int16
			Int32           int32
			Int32Ptr        *int32
			Int32Alias      Int32Alias
			Int32AliasPtr   *Int32Alias
			Uint8           uint8
			Uint8Ptr        *uint8
			Uint16          uint16
			Uint16Ptr       *uint16
			Uint32          uint32
			Uint32Ptr       *uint32
			Float32         float32
			Float32Ptr      *float32
			Float32Alias    Float32Alias
			Float32AliasPtr *Float32Alias
			Float64         float64
			Float64Ptr      *float64
			String          string
			StringPtr       *string
			StringAlias     StringAlias
			StringAliasPtr  *StringAlias
			Struct          struct{}
			StructPtr       *Inner
		})(obj))
		if err != nil {
			return nil, err
		}
		setNull := func(b bool) {
			if b {
				*p = nil
			} else {
				*p = obj
			}
		}
		return libjson.NewNullable(jv, *p == nil, setNull), nil
	}

}

func ast_Struct_Struct_string(obj *struct{ Struct struct{ String string } }) (libjson.Value, error) {

	result := libjson.Object{}

	// Struct struct{String string}
	{
		obj := &obj.Struct
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Struct_string((*struct{ String string })(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Struct"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Struct was empty")
		} //FIXME:
	}

	return result, nil

}

func ast_Struct(obj *struct{}) (libjson.Value, error) {

	result := libjson.Object{}
	_ = obj

	return result, nil

}

func ast_Struct_string(obj *struct{ String string }) (libjson.Value, error) {

	result := libjson.Object{}

	// String string
	{
		obj := &obj.String
		_ = obj //FIXME: remove when other Kinds are done

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_string((*string)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "String"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: String was empty")
		} //FIXME:
	}

	return result, nil

}
