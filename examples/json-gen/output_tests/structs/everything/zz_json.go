// +build !ignore_autogenerated

/*
Copyright 2017 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// This file was autogenerated by json-gen. Do not edit it manually!

package test

import (
	bytes "bytes"
	libjson "k8s.io/gengo/examples/json-gen/libjson"
)

func (obj Ttest) MarshalJSON() ([]byte, error) {
	jv, err := ast_everything_Ttest(&obj)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	if err := jv.Render(&buf); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (obj *Ttest) UnmarshalJSON(data []byte) error {
	jv, err := ast_everything_Ttest(obj)
	if err != nil {
		return err
	}
	return jv.Parse(data)
}

func ast_everything_Ttest(obj *Ttest) (libjson.Value, error) {

	result := libjson.NewObject()

	// Byte byte
	{
		obj := &obj.Byte

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_byte((*byte)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Byte"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Byte was empty")
		} //FIXME:
	}

	// BytePtr *byte
	{
		obj := &obj.BytePtr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_byte((**byte)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "BytePtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: BytePtr was empty")
		} //FIXME:
	}

	// ByteAlias k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.ByteAlias
	{
		obj := &obj.ByteAlias

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_everything_ByteAlias((*ByteAlias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "ByteAlias"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: ByteAlias was empty")
		} //FIXME:
	}

	// ByteAliasPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.ByteAlias
	{
		obj := &obj.ByteAliasPtr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_everything_ByteAlias((**ByteAlias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "ByteAliasPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: ByteAliasPtr was empty")
		} //FIXME:
	}

	// Bool bool
	{
		obj := &obj.Bool

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_bool((*bool)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Bool"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Bool was empty")
		} //FIXME:
	}

	// BoolPtr *bool
	{
		obj := &obj.BoolPtr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_bool((**bool)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "BoolPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: BoolPtr was empty")
		} //FIXME:
	}

	// BoolAlias k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.BoolAlias
	{
		obj := &obj.BoolAlias

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_everything_BoolAlias((*BoolAlias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "BoolAlias"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: BoolAlias was empty")
		} //FIXME:
	}

	// BoolAliasPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.BoolAlias
	{
		obj := &obj.BoolAliasPtr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_everything_BoolAlias((**BoolAlias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "BoolAliasPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: BoolAliasPtr was empty")
		} //FIXME:
	}

	// Int8 int8
	{
		obj := &obj.Int8

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_int8((*int8)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Int8"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Int8 was empty")
		} //FIXME:
	}

	// Int8Ptr *int8
	{
		obj := &obj.Int8Ptr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_int8((**int8)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Int8Ptr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Int8Ptr was empty")
		} //FIXME:
	}

	// Int16 int16
	{
		obj := &obj.Int16

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_int16((*int16)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Int16"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Int16 was empty")
		} //FIXME:
	}

	// Int16Ptr *int16
	{
		obj := &obj.Int16Ptr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_int16((**int16)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Int16Ptr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Int16Ptr was empty")
		} //FIXME:
	}

	// Int32 int32
	{
		obj := &obj.Int32

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_int32((*int32)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Int32"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Int32 was empty")
		} //FIXME:
	}

	// Int32Ptr *int32
	{
		obj := &obj.Int32Ptr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_int32((**int32)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Int32Ptr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Int32Ptr was empty")
		} //FIXME:
	}

	// Int32Alias k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.Int32Alias
	{
		obj := &obj.Int32Alias

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_everything_Int32Alias((*Int32Alias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Int32Alias"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Int32Alias was empty")
		} //FIXME:
	}

	// Int32AliasPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.Int32Alias
	{
		obj := &obj.Int32AliasPtr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_everything_Int32Alias((**Int32Alias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Int32AliasPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Int32AliasPtr was empty")
		} //FIXME:
	}

	// Uint8 uint8
	{
		obj := &obj.Uint8

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_uint8((*uint8)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Uint8"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Uint8 was empty")
		} //FIXME:
	}

	// Uint8Ptr *uint8
	{
		obj := &obj.Uint8Ptr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_uint8((**uint8)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Uint8Ptr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Uint8Ptr was empty")
		} //FIXME:
	}

	// Uint16 uint16
	{
		obj := &obj.Uint16

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_uint16((*uint16)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Uint16"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Uint16 was empty")
		} //FIXME:
	}

	// Uint16Ptr *uint16
	{
		obj := &obj.Uint16Ptr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_uint16((**uint16)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Uint16Ptr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Uint16Ptr was empty")
		} //FIXME:
	}

	// Uint32 uint32
	{
		obj := &obj.Uint32

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_uint32((*uint32)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Uint32"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Uint32 was empty")
		} //FIXME:
	}

	// Uint32Ptr *uint32
	{
		obj := &obj.Uint32Ptr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_uint32((**uint32)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Uint32Ptr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Uint32Ptr was empty")
		} //FIXME:
	}

	// Float32 float32
	{
		obj := &obj.Float32

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_float32((*float32)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Float32"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Float32 was empty")
		} //FIXME:
	}

	// Float32Ptr *float32
	{
		obj := &obj.Float32Ptr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_float32((**float32)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Float32Ptr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Float32Ptr was empty")
		} //FIXME:
	}

	// Float32Alias k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.Float32Alias
	{
		obj := &obj.Float32Alias

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_everything_Float32Alias((*Float32Alias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Float32Alias"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Float32Alias was empty")
		} //FIXME:
	}

	// Float32AliasPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.Float32Alias
	{
		obj := &obj.Float32AliasPtr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_everything_Float32Alias((**Float32Alias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Float32AliasPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Float32AliasPtr was empty")
		} //FIXME:
	}

	// Float64 float64
	{
		obj := &obj.Float64

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_float64((*float64)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Float64"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Float64 was empty")
		} //FIXME:
	}

	// Float64Ptr *float64
	{
		obj := &obj.Float64Ptr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_float64((**float64)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Float64Ptr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Float64Ptr was empty")
		} //FIXME:
	}

	// String string
	{
		obj := &obj.String

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_string((*string)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "String"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: String was empty")
		} //FIXME:
	}

	// StringPtr *string
	{
		obj := &obj.StringPtr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_string((**string)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "StringPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: StringPtr was empty")
		} //FIXME:
	}

	// StringAlias k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.StringAlias
	{
		obj := &obj.StringAlias

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_everything_StringAlias((*StringAlias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "StringAlias"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: StringAlias was empty")
		} //FIXME:
	}

	// StringAliasPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.StringAlias
	{
		obj := &obj.StringAliasPtr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_everything_StringAlias((**StringAlias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "StringAliasPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: StringAliasPtr was empty")
		} //FIXME:
	}

	// StructPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.Inner
	{
		obj := &obj.StructPtr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_everything_Inner((**Inner)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "StructPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: StructPtr was empty")
		} //FIXME:
	}

	// Struct struct{Struct struct{Struct struct{Struct struct{String string}}}}
	{
		obj := &obj.Struct

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Struct_Struct_Struct_Struct_Struct_Struct_Struct_String_string((*struct {
			Struct struct {
				Struct struct{ Struct struct{ String string } }
			}
		})(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Struct"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Struct was empty")
		} //FIXME:
	}

	// SliceString []string
	{
		obj := &obj.SliceString

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Slice_string((*[]string)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "SliceString"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: SliceString was empty")
		} //FIXME:
	}

	// SliceStringAlias k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.SliceStringAlias
	{
		obj := &obj.SliceStringAlias

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_everything_SliceStringAlias((*SliceStringAlias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "SliceStringAlias"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: SliceStringAlias was empty")
		} //FIXME:
	}

	// SlicePtrString []*string
	{
		obj := &obj.SlicePtrString

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Slice_Pointer_string((*[]*string)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "SlicePtrString"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: SlicePtrString was empty")
		} //FIXME:
	}

	// SliceStringPtrAlias k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.SlicePtrStringAlias
	{
		obj := &obj.SliceStringPtrAlias

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_everything_SlicePtrStringAlias((*SlicePtrStringAlias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "SliceStringPtrAlias"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: SliceStringPtrAlias was empty")
		} //FIXME:
	}

	// SliceStringPtr *[]string
	{
		obj := &obj.SliceStringPtr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_Slice_string((**[]string)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "SliceStringPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: SliceStringPtr was empty")
		} //FIXME:
	}

	// MapStringString map[string]string
	{
		obj := &obj.MapStringString

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Map_string_To_string((*map[string]string)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "MapStringString"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: MapStringString was empty")
		} //FIXME:
	}

	// MapStringStringPtr *map[string]string
	{
		obj := &obj.MapStringStringPtr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_Map_string_To_string((**map[string]string)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "MapStringStringPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: MapStringStringPtr was empty")
		} //FIXME:
	}

	// MapStringStringAlias k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.MapStringStringAlias
	{
		obj := &obj.MapStringStringAlias

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_everything_MapStringStringAlias((*MapStringStringAlias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "MapStringStringAlias"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: MapStringStringAlias was empty")
		} //FIXME:
	}

	// MapStringStringAliasPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.MapStringStringAlias
	{
		obj := &obj.MapStringStringAliasPtr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_everything_MapStringStringAlias((**MapStringStringAlias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "MapStringStringAliasPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: MapStringStringAliasPtr was empty")
		} //FIXME:
	}

	return result, nil

}

func ast_byte(obj *byte) (libjson.Value, error) {

	get := func() float64 {
		return float64(*obj)
	}
	set := func(f float64) {
		*obj = byte(f)
	}
	return libjson.NewInt(get, set), nil

}

func ast_Pointer_byte(obj **byte) (libjson.Value, error) {

	var jv libjson.Value
	var err error
	if *obj != nil {
		obj := *obj
		jv, err = ast_byte((*byte)(obj))
		if err != nil {
			return nil, err
		}
	}
	setNull := func(b bool) (libjson.Value, error) {
		if b {
			*obj = nil
			return nil, nil
		}
		*obj = new(byte)
		obj := *obj
		return ast_byte((*byte)(obj))
	}
	return libjson.NewNullable(jv, setNull), nil

}

func ast_everything_ByteAlias(obj *ByteAlias) (libjson.Value, error) {
	return ast_byte((*byte)(obj))
}

func ast_Pointer_everything_ByteAlias(obj **ByteAlias) (libjson.Value, error) {

	var jv libjson.Value
	var err error
	if *obj != nil {
		obj := *obj
		jv, err = ast_everything_ByteAlias((*ByteAlias)(obj))
		if err != nil {
			return nil, err
		}
	}
	setNull := func(b bool) (libjson.Value, error) {
		if b {
			*obj = nil
			return nil, nil
		}
		*obj = new(ByteAlias)
		obj := *obj
		return ast_everything_ByteAlias((*ByteAlias)(obj))
	}
	return libjson.NewNullable(jv, setNull), nil

}

func ast_bool(obj *bool) (libjson.Value, error) {
	return libjson.NewBool(func() bool { return *obj }, func(b bool) { *obj = b }), nil
}

func ast_Pointer_bool(obj **bool) (libjson.Value, error) {

	var jv libjson.Value
	var err error
	if *obj != nil {
		obj := *obj
		jv, err = ast_bool((*bool)(obj))
		if err != nil {
			return nil, err
		}
	}
	setNull := func(b bool) (libjson.Value, error) {
		if b {
			*obj = nil
			return nil, nil
		}
		*obj = new(bool)
		obj := *obj
		return ast_bool((*bool)(obj))
	}
	return libjson.NewNullable(jv, setNull), nil

}

func ast_everything_BoolAlias(obj *BoolAlias) (libjson.Value, error) {
	return ast_bool((*bool)(obj))
}

func ast_Pointer_everything_BoolAlias(obj **BoolAlias) (libjson.Value, error) {

	var jv libjson.Value
	var err error
	if *obj != nil {
		obj := *obj
		jv, err = ast_everything_BoolAlias((*BoolAlias)(obj))
		if err != nil {
			return nil, err
		}
	}
	setNull := func(b bool) (libjson.Value, error) {
		if b {
			*obj = nil
			return nil, nil
		}
		*obj = new(BoolAlias)
		obj := *obj
		return ast_everything_BoolAlias((*BoolAlias)(obj))
	}
	return libjson.NewNullable(jv, setNull), nil

}

func ast_int8(obj *int8) (libjson.Value, error) {

	get := func() float64 {
		return float64(*obj)
	}
	set := func(f float64) {
		*obj = int8(f)
	}
	return libjson.NewInt(get, set), nil

}

func ast_Pointer_int8(obj **int8) (libjson.Value, error) {

	var jv libjson.Value
	var err error
	if *obj != nil {
		obj := *obj
		jv, err = ast_int8((*int8)(obj))
		if err != nil {
			return nil, err
		}
	}
	setNull := func(b bool) (libjson.Value, error) {
		if b {
			*obj = nil
			return nil, nil
		}
		*obj = new(int8)
		obj := *obj
		return ast_int8((*int8)(obj))
	}
	return libjson.NewNullable(jv, setNull), nil

}

func ast_int16(obj *int16) (libjson.Value, error) {

	get := func() float64 {
		return float64(*obj)
	}
	set := func(f float64) {
		*obj = int16(f)
	}
	return libjson.NewInt(get, set), nil

}

func ast_Pointer_int16(obj **int16) (libjson.Value, error) {

	var jv libjson.Value
	var err error
	if *obj != nil {
		obj := *obj
		jv, err = ast_int16((*int16)(obj))
		if err != nil {
			return nil, err
		}
	}
	setNull := func(b bool) (libjson.Value, error) {
		if b {
			*obj = nil
			return nil, nil
		}
		*obj = new(int16)
		obj := *obj
		return ast_int16((*int16)(obj))
	}
	return libjson.NewNullable(jv, setNull), nil

}

func ast_int32(obj *int32) (libjson.Value, error) {

	get := func() float64 {
		return float64(*obj)
	}
	set := func(f float64) {
		*obj = int32(f)
	}
	return libjson.NewInt(get, set), nil

}

func ast_Pointer_int32(obj **int32) (libjson.Value, error) {

	var jv libjson.Value
	var err error
	if *obj != nil {
		obj := *obj
		jv, err = ast_int32((*int32)(obj))
		if err != nil {
			return nil, err
		}
	}
	setNull := func(b bool) (libjson.Value, error) {
		if b {
			*obj = nil
			return nil, nil
		}
		*obj = new(int32)
		obj := *obj
		return ast_int32((*int32)(obj))
	}
	return libjson.NewNullable(jv, setNull), nil

}

func ast_everything_Int32Alias(obj *Int32Alias) (libjson.Value, error) {
	return ast_int32((*int32)(obj))
}

func ast_Pointer_everything_Int32Alias(obj **Int32Alias) (libjson.Value, error) {

	var jv libjson.Value
	var err error
	if *obj != nil {
		obj := *obj
		jv, err = ast_everything_Int32Alias((*Int32Alias)(obj))
		if err != nil {
			return nil, err
		}
	}
	setNull := func(b bool) (libjson.Value, error) {
		if b {
			*obj = nil
			return nil, nil
		}
		*obj = new(Int32Alias)
		obj := *obj
		return ast_everything_Int32Alias((*Int32Alias)(obj))
	}
	return libjson.NewNullable(jv, setNull), nil

}

func ast_uint8(obj *uint8) (libjson.Value, error) {

	get := func() float64 {
		return float64(*obj)
	}
	set := func(f float64) {
		*obj = uint8(f)
	}
	return libjson.NewInt(get, set), nil

}

func ast_Pointer_uint8(obj **uint8) (libjson.Value, error) {

	var jv libjson.Value
	var err error
	if *obj != nil {
		obj := *obj
		jv, err = ast_uint8((*uint8)(obj))
		if err != nil {
			return nil, err
		}
	}
	setNull := func(b bool) (libjson.Value, error) {
		if b {
			*obj = nil
			return nil, nil
		}
		*obj = new(uint8)
		obj := *obj
		return ast_uint8((*uint8)(obj))
	}
	return libjson.NewNullable(jv, setNull), nil

}

func ast_uint16(obj *uint16) (libjson.Value, error) {

	get := func() float64 {
		return float64(*obj)
	}
	set := func(f float64) {
		*obj = uint16(f)
	}
	return libjson.NewInt(get, set), nil

}

func ast_Pointer_uint16(obj **uint16) (libjson.Value, error) {

	var jv libjson.Value
	var err error
	if *obj != nil {
		obj := *obj
		jv, err = ast_uint16((*uint16)(obj))
		if err != nil {
			return nil, err
		}
	}
	setNull := func(b bool) (libjson.Value, error) {
		if b {
			*obj = nil
			return nil, nil
		}
		*obj = new(uint16)
		obj := *obj
		return ast_uint16((*uint16)(obj))
	}
	return libjson.NewNullable(jv, setNull), nil

}

func ast_uint32(obj *uint32) (libjson.Value, error) {

	get := func() float64 {
		return float64(*obj)
	}
	set := func(f float64) {
		*obj = uint32(f)
	}
	return libjson.NewInt(get, set), nil

}

func ast_Pointer_uint32(obj **uint32) (libjson.Value, error) {

	var jv libjson.Value
	var err error
	if *obj != nil {
		obj := *obj
		jv, err = ast_uint32((*uint32)(obj))
		if err != nil {
			return nil, err
		}
	}
	setNull := func(b bool) (libjson.Value, error) {
		if b {
			*obj = nil
			return nil, nil
		}
		*obj = new(uint32)
		obj := *obj
		return ast_uint32((*uint32)(obj))
	}
	return libjson.NewNullable(jv, setNull), nil

}

func ast_float32(obj *float32) (libjson.Value, error) {

	get := func() float64 {
		return float64(*obj)
	}
	set := func(f float64) {
		*obj = float32(f)
	}
	return libjson.NewFloat(32, get, set), nil

}

func ast_Pointer_float32(obj **float32) (libjson.Value, error) {

	var jv libjson.Value
	var err error
	if *obj != nil {
		obj := *obj
		jv, err = ast_float32((*float32)(obj))
		if err != nil {
			return nil, err
		}
	}
	setNull := func(b bool) (libjson.Value, error) {
		if b {
			*obj = nil
			return nil, nil
		}
		*obj = new(float32)
		obj := *obj
		return ast_float32((*float32)(obj))
	}
	return libjson.NewNullable(jv, setNull), nil

}

func ast_everything_Float32Alias(obj *Float32Alias) (libjson.Value, error) {
	return ast_float32((*float32)(obj))
}

func ast_Pointer_everything_Float32Alias(obj **Float32Alias) (libjson.Value, error) {

	var jv libjson.Value
	var err error
	if *obj != nil {
		obj := *obj
		jv, err = ast_everything_Float32Alias((*Float32Alias)(obj))
		if err != nil {
			return nil, err
		}
	}
	setNull := func(b bool) (libjson.Value, error) {
		if b {
			*obj = nil
			return nil, nil
		}
		*obj = new(Float32Alias)
		obj := *obj
		return ast_everything_Float32Alias((*Float32Alias)(obj))
	}
	return libjson.NewNullable(jv, setNull), nil

}

func ast_float64(obj *float64) (libjson.Value, error) {

	get := func() float64 {
		return float64(*obj)
	}
	set := func(f float64) {
		*obj = float64(f)
	}
	return libjson.NewFloat(64, get, set), nil

}

func ast_Pointer_float64(obj **float64) (libjson.Value, error) {

	var jv libjson.Value
	var err error
	if *obj != nil {
		obj := *obj
		jv, err = ast_float64((*float64)(obj))
		if err != nil {
			return nil, err
		}
	}
	setNull := func(b bool) (libjson.Value, error) {
		if b {
			*obj = nil
			return nil, nil
		}
		*obj = new(float64)
		obj := *obj
		return ast_float64((*float64)(obj))
	}
	return libjson.NewNullable(jv, setNull), nil

}

func ast_string(obj *string) (libjson.Value, error) {
	return libjson.NewString(func() string { return *obj }, func(s string) { *obj = s }), nil
}

func ast_Pointer_string(obj **string) (libjson.Value, error) {

	var jv libjson.Value
	var err error
	if *obj != nil {
		obj := *obj
		jv, err = ast_string((*string)(obj))
		if err != nil {
			return nil, err
		}
	}
	setNull := func(b bool) (libjson.Value, error) {
		if b {
			*obj = nil
			return nil, nil
		}
		*obj = new(string)
		obj := *obj
		return ast_string((*string)(obj))
	}
	return libjson.NewNullable(jv, setNull), nil

}

func ast_everything_StringAlias(obj *StringAlias) (libjson.Value, error) {
	return ast_string((*string)(obj))
}

func ast_Pointer_everything_StringAlias(obj **StringAlias) (libjson.Value, error) {

	var jv libjson.Value
	var err error
	if *obj != nil {
		obj := *obj
		jv, err = ast_everything_StringAlias((*StringAlias)(obj))
		if err != nil {
			return nil, err
		}
	}
	setNull := func(b bool) (libjson.Value, error) {
		if b {
			*obj = nil
			return nil, nil
		}
		*obj = new(StringAlias)
		obj := *obj
		return ast_everything_StringAlias((*StringAlias)(obj))
	}
	return libjson.NewNullable(jv, setNull), nil

}

func ast_Pointer_everything_Inner(obj **Inner) (libjson.Value, error) {

	var jv libjson.Value
	var err error
	if *obj != nil {
		obj := *obj
		jv, err = ast_everything_Inner((*Inner)(obj))
		if err != nil {
			return nil, err
		}
	}
	setNull := func(b bool) (libjson.Value, error) {
		if b {
			*obj = nil
			return nil, nil
		}
		*obj = new(Inner)
		obj := *obj
		return ast_everything_Inner((*Inner)(obj))
	}
	return libjson.NewNullable(jv, setNull), nil

}

func ast_Struct_Struct_Struct_Struct_Struct_Struct_Struct_String_string(obj *struct {
	Struct struct {
		Struct struct{ Struct struct{ String string } }
	}
}) (libjson.Value, error) {

	result := libjson.NewObject()

	// Struct struct{Struct struct{Struct struct{String string}}}
	{
		obj := &obj.Struct

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Struct_Struct_Struct_Struct_Struct_String_string((*struct {
			Struct struct{ Struct struct{ String string } }
		})(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Struct"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Struct was empty")
		} //FIXME:
	}

	return result, nil

}

func ast_Slice_string(obj *[]string) (libjson.Value, error) {

	get := func() ([]libjson.Value, error) {
		if *obj == nil {
			return nil, nil
		}
		result := []libjson.Value{}
		for i := range *obj {
			obj := &(*obj)[i]
			//FIXME: do any of these ACTUALLY return an error?
			jv, err := ast_string((*string)(obj))
			if err != nil {
				return nil, err
			}
			result = append(result, jv)
		}
		return result, nil
	}
	add := func() libjson.Value {
		var x string
		*obj = append(*obj, x)
		obj := &(*obj)[len(*obj)-1]
		jv, _ := ast_string((*string)(obj))
		//FIXME: handle error?
		return jv
	}
	var jv libjson.Value
	if *obj != nil {
		jv = libjson.NewArray(get, add)
	}
	setNull := func(b bool) (libjson.Value, error) {
		if b {
			*obj = nil
			return nil, nil
		}
		*obj = []string{}
		return libjson.NewArray(get, add), nil
	}
	return libjson.NewNullable(jv, setNull), nil

}

func ast_everything_SliceStringAlias(obj *SliceStringAlias) (libjson.Value, error) {
	return ast_Slice_string((*[]string)(obj))
}

func ast_Slice_Pointer_string(obj *[]*string) (libjson.Value, error) {

	get := func() ([]libjson.Value, error) {
		if *obj == nil {
			return nil, nil
		}
		result := []libjson.Value{}
		for i := range *obj {
			obj := &(*obj)[i]
			//FIXME: do any of these ACTUALLY return an error?
			jv, err := ast_Pointer_string((**string)(obj))
			if err != nil {
				return nil, err
			}
			result = append(result, jv)
		}
		return result, nil
	}
	add := func() libjson.Value {
		var x *string
		*obj = append(*obj, x)
		obj := &(*obj)[len(*obj)-1]
		jv, _ := ast_Pointer_string((**string)(obj))
		//FIXME: handle error?
		return jv
	}
	var jv libjson.Value
	if *obj != nil {
		jv = libjson.NewArray(get, add)
	}
	setNull := func(b bool) (libjson.Value, error) {
		if b {
			*obj = nil
			return nil, nil
		}
		*obj = []*string{}
		return libjson.NewArray(get, add), nil
	}
	return libjson.NewNullable(jv, setNull), nil

}

func ast_everything_SlicePtrStringAlias(obj *SlicePtrStringAlias) (libjson.Value, error) {
	return ast_Slice_Pointer_string((*[]*string)(obj))
}

func ast_Pointer_Slice_string(obj **[]string) (libjson.Value, error) {

	var jv libjson.Value
	var err error
	if *obj != nil {
		obj := *obj
		jv, err = ast_Slice_string((*[]string)(obj))
		if err != nil {
			return nil, err
		}
	}
	setNull := func(b bool) (libjson.Value, error) {
		if b {
			*obj = nil
			return nil, nil
		}
		*obj = new([]string)
		obj := *obj
		return ast_Slice_string((*[]string)(obj))
	}
	return libjson.NewNullable(jv, setNull), nil

}

func ast_Map_string_To_string(obj *map[string]string) (libjson.Value, error) {

	keyToString := func(k string) (string, error) {
		return string(k), nil
	}
	keyFromString := func(s string) (string, error) {
		return string(s), nil
	}

	var keys []string
	var vals []string
	add := func(ks string) libjson.Value {
		if k, err := keyFromString(ks); err != nil {
			panic(err) //FIXME
		} else {
			keys = append(keys, k)
		}
		var x string
		vals = append(vals, x)
		obj := &vals[len(vals)-1]
		jv, _ := ast_string((*string)(obj))
		//FIXME: handle error?
		return jv
	}
	get := func() (map[string]libjson.Value, error) {
		if *obj == nil && keys == nil {
			return nil, nil
		}
		result := map[string]libjson.Value{}
		for k, v := range *obj {
			obj := new(string)
			*obj = v
			//FIXME: do any of these ACTUALLY return an error?
			jv, err := ast_string((*string)(obj))
			if err != nil {
				return nil, err
			}
			if ks, err := keyToString(k); err != nil {
				panic(err)
			} else {
				result[ks] = jv
			}
		}
		for i := range keys {
			obj := &vals[i]
			//FIXME: do any of these ACTUALLY return an error?
			jv, err := ast_string((*string)(obj))
			if err != nil {
				return nil, err
			}
			if ks, err := keyToString(keys[i]); err != nil {
				panic(err)
			} else {
				result[ks] = jv
			}
		}
		return result, nil
	}
	finishParse := func() {
		for i := range keys {
			(*obj)[keys[i]] = vals[i]
		}
	}
	var jv libjson.Value
	if *obj != nil {
		jv = libjson.NewMap(add, get, finishParse)
	}
	setNull := func(b bool) (libjson.Value, error) {
		if b {
			*obj = nil
			return nil, nil
		}
		*obj = map[string]string{}
		return libjson.NewMap(add, get, finishParse), nil
	}
	return libjson.NewNullable(jv, setNull), nil

}

func ast_Pointer_Map_string_To_string(obj **map[string]string) (libjson.Value, error) {

	var jv libjson.Value
	var err error
	if *obj != nil {
		obj := *obj
		jv, err = ast_Map_string_To_string((*map[string]string)(obj))
		if err != nil {
			return nil, err
		}
	}
	setNull := func(b bool) (libjson.Value, error) {
		if b {
			*obj = nil
			return nil, nil
		}
		*obj = new(map[string]string)
		obj := *obj
		return ast_Map_string_To_string((*map[string]string)(obj))
	}
	return libjson.NewNullable(jv, setNull), nil

}

func ast_everything_MapStringStringAlias(obj *MapStringStringAlias) (libjson.Value, error) {
	return ast_Map_string_To_string((*map[string]string)(obj))
}

func ast_Pointer_everything_MapStringStringAlias(obj **MapStringStringAlias) (libjson.Value, error) {

	var jv libjson.Value
	var err error
	if *obj != nil {
		obj := *obj
		jv, err = ast_everything_MapStringStringAlias((*MapStringStringAlias)(obj))
		if err != nil {
			return nil, err
		}
	}
	setNull := func(b bool) (libjson.Value, error) {
		if b {
			*obj = nil
			return nil, nil
		}
		*obj = new(MapStringStringAlias)
		obj := *obj
		return ast_everything_MapStringStringAlias((*MapStringStringAlias)(obj))
	}
	return libjson.NewNullable(jv, setNull), nil

}

func ast_everything_Inner(obj *Inner) (libjson.Value, error) {

	result := libjson.NewObject()

	// Byte byte
	{
		obj := &obj.Byte

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_byte((*byte)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Byte"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Byte was empty")
		} //FIXME:
	}

	// BytePtr *byte
	{
		obj := &obj.BytePtr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_byte((**byte)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "BytePtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: BytePtr was empty")
		} //FIXME:
	}

	// ByteAlias k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.ByteAlias
	{
		obj := &obj.ByteAlias

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_everything_ByteAlias((*ByteAlias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "ByteAlias"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: ByteAlias was empty")
		} //FIXME:
	}

	// ByteAliasPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.ByteAlias
	{
		obj := &obj.ByteAliasPtr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_everything_ByteAlias((**ByteAlias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "ByteAliasPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: ByteAliasPtr was empty")
		} //FIXME:
	}

	// Bool bool
	{
		obj := &obj.Bool

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_bool((*bool)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Bool"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Bool was empty")
		} //FIXME:
	}

	// BoolPtr *bool
	{
		obj := &obj.BoolPtr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_bool((**bool)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "BoolPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: BoolPtr was empty")
		} //FIXME:
	}

	// BoolAlias k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.BoolAlias
	{
		obj := &obj.BoolAlias

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_everything_BoolAlias((*BoolAlias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "BoolAlias"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: BoolAlias was empty")
		} //FIXME:
	}

	// BoolAliasPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.BoolAlias
	{
		obj := &obj.BoolAliasPtr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_everything_BoolAlias((**BoolAlias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "BoolAliasPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: BoolAliasPtr was empty")
		} //FIXME:
	}

	// Int8 int8
	{
		obj := &obj.Int8

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_int8((*int8)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Int8"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Int8 was empty")
		} //FIXME:
	}

	// Int8Ptr *int8
	{
		obj := &obj.Int8Ptr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_int8((**int8)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Int8Ptr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Int8Ptr was empty")
		} //FIXME:
	}

	// Int16 int16
	{
		obj := &obj.Int16

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_int16((*int16)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Int16"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Int16 was empty")
		} //FIXME:
	}

	// Int16Ptr *int16
	{
		obj := &obj.Int16Ptr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_int16((**int16)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Int16Ptr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Int16Ptr was empty")
		} //FIXME:
	}

	// Int32 int32
	{
		obj := &obj.Int32

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_int32((*int32)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Int32"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Int32 was empty")
		} //FIXME:
	}

	// Int32Ptr *int32
	{
		obj := &obj.Int32Ptr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_int32((**int32)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Int32Ptr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Int32Ptr was empty")
		} //FIXME:
	}

	// Int32Alias k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.Int32Alias
	{
		obj := &obj.Int32Alias

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_everything_Int32Alias((*Int32Alias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Int32Alias"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Int32Alias was empty")
		} //FIXME:
	}

	// Int32AliasPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.Int32Alias
	{
		obj := &obj.Int32AliasPtr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_everything_Int32Alias((**Int32Alias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Int32AliasPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Int32AliasPtr was empty")
		} //FIXME:
	}

	// Uint8 uint8
	{
		obj := &obj.Uint8

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_uint8((*uint8)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Uint8"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Uint8 was empty")
		} //FIXME:
	}

	// Uint8Ptr *uint8
	{
		obj := &obj.Uint8Ptr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_uint8((**uint8)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Uint8Ptr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Uint8Ptr was empty")
		} //FIXME:
	}

	// Uint16 uint16
	{
		obj := &obj.Uint16

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_uint16((*uint16)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Uint16"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Uint16 was empty")
		} //FIXME:
	}

	// Uint16Ptr *uint16
	{
		obj := &obj.Uint16Ptr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_uint16((**uint16)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Uint16Ptr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Uint16Ptr was empty")
		} //FIXME:
	}

	// Uint32 uint32
	{
		obj := &obj.Uint32

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_uint32((*uint32)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Uint32"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Uint32 was empty")
		} //FIXME:
	}

	// Uint32Ptr *uint32
	{
		obj := &obj.Uint32Ptr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_uint32((**uint32)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Uint32Ptr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Uint32Ptr was empty")
		} //FIXME:
	}

	// Float32 float32
	{
		obj := &obj.Float32

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_float32((*float32)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Float32"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Float32 was empty")
		} //FIXME:
	}

	// Float32Ptr *float32
	{
		obj := &obj.Float32Ptr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_float32((**float32)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Float32Ptr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Float32Ptr was empty")
		} //FIXME:
	}

	// Float32Alias k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.Float32Alias
	{
		obj := &obj.Float32Alias

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_everything_Float32Alias((*Float32Alias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Float32Alias"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Float32Alias was empty")
		} //FIXME:
	}

	// Float32AliasPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.Float32Alias
	{
		obj := &obj.Float32AliasPtr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_everything_Float32Alias((**Float32Alias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Float32AliasPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Float32AliasPtr was empty")
		} //FIXME:
	}

	// Float64 float64
	{
		obj := &obj.Float64

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_float64((*float64)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Float64"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Float64 was empty")
		} //FIXME:
	}

	// Float64Ptr *float64
	{
		obj := &obj.Float64Ptr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_float64((**float64)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Float64Ptr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Float64Ptr was empty")
		} //FIXME:
	}

	// String string
	{
		obj := &obj.String

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_string((*string)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "String"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: String was empty")
		} //FIXME:
	}

	// StringPtr *string
	{
		obj := &obj.StringPtr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_string((**string)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "StringPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: StringPtr was empty")
		} //FIXME:
	}

	// StringAlias k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.StringAlias
	{
		obj := &obj.StringAlias

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_everything_StringAlias((*StringAlias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "StringAlias"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: StringAlias was empty")
		} //FIXME:
	}

	// StringAliasPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.StringAlias
	{
		obj := &obj.StringAliasPtr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_everything_StringAlias((**StringAlias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "StringAliasPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: StringAliasPtr was empty")
		} //FIXME:
	}

	// Struct struct{Byte byte; BytePtr *byte; ByteAlias k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.ByteAlias; ByteAliasPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.ByteAlias; Bool bool; BoolPtr *bool; BoolAlias k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.BoolAlias; BoolAliasPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.BoolAlias; Int8 int8; Int8Ptr *int8; Int16 int16; Int16Ptr *int16; Int32 int32; Int32Ptr *int32; Int32Alias k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.Int32Alias; Int32AliasPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.Int32Alias; Uint8 uint8; Uint8Ptr *uint8; Uint16 uint16; Uint16Ptr *uint16; Uint32 uint32; Uint32Ptr *uint32; Float32 float32; Float32Ptr *float32; Float32Alias k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.Float32Alias; Float32AliasPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.Float32Alias; Float64 float64; Float64Ptr *float64; String string; StringPtr *string; StringAlias k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.StringAlias; StringAliasPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.StringAlias; Struct struct{}; StructPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.Inner; SliceString []string; SliceStringAlias k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.SliceStringAlias; SlicePtrString []*string; SliceStringPtrAlias k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.SlicePtrStringAlias; SliceStringPtr *[]string; SliceByte []byte}
	{
		obj := &obj.Struct

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Struct_Byte_byte_BytePtr_Pointer_byte_ByteAlias_everything_ByteAlias_ByteAliasPtr_Pointer_everything_ByteAlias_Bool_bool_BoolPtr_Pointer_bool_BoolAlias_everything_BoolAlias_BoolAliasPtr_Pointer_everything_BoolAlias_Int8_int8_Int8Ptr_Pointer_int8_Int16_int16_Int16Ptr_Pointer_int16_Int32_int32_Int32Ptr_Pointer_int32_Int32Alias_everything_Int32Alias_Int32AliasPtr_Pointer_everything_Int32Alias_Uint8_uint8_Uint8Ptr_Pointer_uint8_Uint16_uint16_Uint16Ptr_Pointer_uint16_Uint32_uint32_Uint32Ptr_Pointer_uint32_Float32_float32_Float32Ptr_Pointer_float32_Float32Alias_everything_Float32Alias_Float32AliasPtr_Pointer_everything_Float32Alias_Float64_float64_Float64Ptr_Pointer_float64_String_string_StringPtr_Pointer_string_StringAlias_everything_StringAlias_StringAliasPtr_Pointer_everything_StringAlias_Struct_Struct_StructPtr_Pointer_everything_Inner_SliceString_Slice_string_SliceStringAlias_everything_SliceStringAlias_SlicePtrString_Slice_Pointer_string_SliceStringPtrAlias_everything_SlicePtrStringAlias_SliceStringPtr_Pointer_Slice_string_SliceByte_Slice_byte((*struct {
			Byte                byte
			BytePtr             *byte
			ByteAlias           ByteAlias
			ByteAliasPtr        *ByteAlias
			Bool                bool
			BoolPtr             *bool
			BoolAlias           BoolAlias
			BoolAliasPtr        *BoolAlias
			Int8                int8
			Int8Ptr             *int8
			Int16               int16
			Int16Ptr            *int16
			Int32               int32
			Int32Ptr            *int32
			Int32Alias          Int32Alias
			Int32AliasPtr       *Int32Alias
			Uint8               uint8
			Uint8Ptr            *uint8
			Uint16              uint16
			Uint16Ptr           *uint16
			Uint32              uint32
			Uint32Ptr           *uint32
			Float32             float32
			Float32Ptr          *float32
			Float32Alias        Float32Alias
			Float32AliasPtr     *Float32Alias
			Float64             float64
			Float64Ptr          *float64
			String              string
			StringPtr           *string
			StringAlias         StringAlias
			StringAliasPtr      *StringAlias
			Struct              struct{}
			StructPtr           *Inner
			SliceString         []string
			SliceStringAlias    SliceStringAlias
			SlicePtrString      []*string
			SliceStringPtrAlias SlicePtrStringAlias
			SliceStringPtr      *[]string
			SliceByte           []byte
		})(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Struct"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Struct was empty")
		} //FIXME:
	}

	// StructPtr *struct{Byte byte; BytePtr *byte; ByteAlias k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.ByteAlias; ByteAliasPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.ByteAlias; Bool bool; BoolPtr *bool; BoolAlias k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.BoolAlias; BoolAliasPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.BoolAlias; Int8 int8; Int8Ptr *int8; Int16 int16; Int16Ptr *int16; Int32 int32; Int32Ptr *int32; Int32Alias k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.Int32Alias; Int32AliasPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.Int32Alias; Uint8 uint8; Uint8Ptr *uint8; Uint16 uint16; Uint16Ptr *uint16; Uint32 uint32; Uint32Ptr *uint32; Float32 float32; Float32Ptr *float32; Float32Alias k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.Float32Alias; Float32AliasPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.Float32Alias; Float64 float64; Float64Ptr *float64; String string; StringPtr *string; StringAlias k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.StringAlias; StringAliasPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.StringAlias; Struct struct{}; StructPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.Inner; SliceString []string; SliceStringAlias k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.SliceStringAlias; SlicePtrString []*string; SliceStringPtrAlias k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.SlicePtrStringAlias; SliceStringPtr *[]string; SliceByte []byte; MapStringString map[string]string; MapStringStringPtr *map[string]string; MapStringStringAlias k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.MapStringStringAlias; MapStringStringAliasPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.MapStringStringAlias}
	{
		obj := &obj.StructPtr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_Struct_Byte_byte_BytePtr_Pointer_byte_ByteAlias_everything_ByteAlias_ByteAliasPtr_Pointer_everything_ByteAlias_Bool_bool_BoolPtr_Pointer_bool_BoolAlias_everything_BoolAlias_BoolAliasPtr_Pointer_everything_BoolAlias_Int8_int8_Int8Ptr_Pointer_int8_Int16_int16_Int16Ptr_Pointer_int16_Int32_int32_Int32Ptr_Pointer_int32_Int32Alias_everything_Int32Alias_Int32AliasPtr_Pointer_everything_Int32Alias_Uint8_uint8_Uint8Ptr_Pointer_uint8_Uint16_uint16_Uint16Ptr_Pointer_uint16_Uint32_uint32_Uint32Ptr_Pointer_uint32_Float32_float32_Float32Ptr_Pointer_float32_Float32Alias_everything_Float32Alias_Float32AliasPtr_Pointer_everything_Float32Alias_Float64_float64_Float64Ptr_Pointer_float64_String_string_StringPtr_Pointer_string_StringAlias_everything_StringAlias_StringAliasPtr_Pointer_everything_StringAlias_Struct_Struct_StructPtr_Pointer_everything_Inner_SliceString_Slice_string_SliceStringAlias_everything_SliceStringAlias_SlicePtrString_Slice_Pointer_string_SliceStringPtrAlias_everything_SlicePtrStringAlias_SliceStringPtr_Pointer_Slice_string_SliceByte_Slice_byte_MapStringString_Map_string_To_string_MapStringStringPtr_Pointer_Map_string_To_string_MapStringStringAlias_everything_MapStringStringAlias_MapStringStringAliasPtr_Pointer_everything_MapStringStringAlias((**struct {
			Byte                    byte
			BytePtr                 *byte
			ByteAlias               ByteAlias
			ByteAliasPtr            *ByteAlias
			Bool                    bool
			BoolPtr                 *bool
			BoolAlias               BoolAlias
			BoolAliasPtr            *BoolAlias
			Int8                    int8
			Int8Ptr                 *int8
			Int16                   int16
			Int16Ptr                *int16
			Int32                   int32
			Int32Ptr                *int32
			Int32Alias              Int32Alias
			Int32AliasPtr           *Int32Alias
			Uint8                   uint8
			Uint8Ptr                *uint8
			Uint16                  uint16
			Uint16Ptr               *uint16
			Uint32                  uint32
			Uint32Ptr               *uint32
			Float32                 float32
			Float32Ptr              *float32
			Float32Alias            Float32Alias
			Float32AliasPtr         *Float32Alias
			Float64                 float64
			Float64Ptr              *float64
			String                  string
			StringPtr               *string
			StringAlias             StringAlias
			StringAliasPtr          *StringAlias
			Struct                  struct{}
			StructPtr               *Inner
			SliceString             []string
			SliceStringAlias        SliceStringAlias
			SlicePtrString          []*string
			SliceStringPtrAlias     SlicePtrStringAlias
			SliceStringPtr          *[]string
			SliceByte               []byte
			MapStringString         map[string]string
			MapStringStringPtr      *map[string]string
			MapStringStringAlias    MapStringStringAlias
			MapStringStringAliasPtr *MapStringStringAlias
		})(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "StructPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: StructPtr was empty")
		} //FIXME:
	}

	// SliceString []string
	{
		obj := &obj.SliceString

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Slice_string((*[]string)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "SliceString"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: SliceString was empty")
		} //FIXME:
	}

	// SliceStringAlias k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.SliceStringAlias
	{
		obj := &obj.SliceStringAlias

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_everything_SliceStringAlias((*SliceStringAlias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "SliceStringAlias"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: SliceStringAlias was empty")
		} //FIXME:
	}

	// SlicePtrString []*string
	{
		obj := &obj.SlicePtrString

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Slice_Pointer_string((*[]*string)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "SlicePtrString"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: SlicePtrString was empty")
		} //FIXME:
	}

	// SliceStringPtrAlias k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.SlicePtrStringAlias
	{
		obj := &obj.SliceStringPtrAlias

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_everything_SlicePtrStringAlias((*SlicePtrStringAlias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "SliceStringPtrAlias"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: SliceStringPtrAlias was empty")
		} //FIXME:
	}

	// SliceStringPtr *[]string
	{
		obj := &obj.SliceStringPtr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_Slice_string((**[]string)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "SliceStringPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: SliceStringPtr was empty")
		} //FIXME:
	}

	// SliceByte []byte
	{
		obj := &obj.SliceByte

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Slice_byte((*[]byte)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "SliceByte"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: SliceByte was empty")
		} //FIXME:
	}

	// MapStringString map[string]string
	{
		obj := &obj.MapStringString

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Map_string_To_string((*map[string]string)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "MapStringString"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: MapStringString was empty")
		} //FIXME:
	}

	// MapStringStringPtr *map[string]string
	{
		obj := &obj.MapStringStringPtr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_Map_string_To_string((**map[string]string)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "MapStringStringPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: MapStringStringPtr was empty")
		} //FIXME:
	}

	// MapStringStringAlias k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.MapStringStringAlias
	{
		obj := &obj.MapStringStringAlias

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_everything_MapStringStringAlias((*MapStringStringAlias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "MapStringStringAlias"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: MapStringStringAlias was empty")
		} //FIXME:
	}

	// MapStringStringAliasPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.MapStringStringAlias
	{
		obj := &obj.MapStringStringAliasPtr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_everything_MapStringStringAlias((**MapStringStringAlias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "MapStringStringAliasPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: MapStringStringAliasPtr was empty")
		} //FIXME:
	}

	return result, nil

}

func ast_Struct_Struct_Struct_Struct_Struct_String_string(obj *struct {
	Struct struct{ Struct struct{ String string } }
}) (libjson.Value, error) {

	result := libjson.NewObject()

	// Struct struct{Struct struct{String string}}
	{
		obj := &obj.Struct

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Struct_Struct_Struct_String_string((*struct{ Struct struct{ String string } })(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Struct"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Struct was empty")
		} //FIXME:
	}

	return result, nil

}

func ast_Struct_Byte_byte_BytePtr_Pointer_byte_ByteAlias_everything_ByteAlias_ByteAliasPtr_Pointer_everything_ByteAlias_Bool_bool_BoolPtr_Pointer_bool_BoolAlias_everything_BoolAlias_BoolAliasPtr_Pointer_everything_BoolAlias_Int8_int8_Int8Ptr_Pointer_int8_Int16_int16_Int16Ptr_Pointer_int16_Int32_int32_Int32Ptr_Pointer_int32_Int32Alias_everything_Int32Alias_Int32AliasPtr_Pointer_everything_Int32Alias_Uint8_uint8_Uint8Ptr_Pointer_uint8_Uint16_uint16_Uint16Ptr_Pointer_uint16_Uint32_uint32_Uint32Ptr_Pointer_uint32_Float32_float32_Float32Ptr_Pointer_float32_Float32Alias_everything_Float32Alias_Float32AliasPtr_Pointer_everything_Float32Alias_Float64_float64_Float64Ptr_Pointer_float64_String_string_StringPtr_Pointer_string_StringAlias_everything_StringAlias_StringAliasPtr_Pointer_everything_StringAlias_Struct_Struct_StructPtr_Pointer_everything_Inner_SliceString_Slice_string_SliceStringAlias_everything_SliceStringAlias_SlicePtrString_Slice_Pointer_string_SliceStringPtrAlias_everything_SlicePtrStringAlias_SliceStringPtr_Pointer_Slice_string_SliceByte_Slice_byte(obj *struct {
	Byte                byte
	BytePtr             *byte
	ByteAlias           ByteAlias
	ByteAliasPtr        *ByteAlias
	Bool                bool
	BoolPtr             *bool
	BoolAlias           BoolAlias
	BoolAliasPtr        *BoolAlias
	Int8                int8
	Int8Ptr             *int8
	Int16               int16
	Int16Ptr            *int16
	Int32               int32
	Int32Ptr            *int32
	Int32Alias          Int32Alias
	Int32AliasPtr       *Int32Alias
	Uint8               uint8
	Uint8Ptr            *uint8
	Uint16              uint16
	Uint16Ptr           *uint16
	Uint32              uint32
	Uint32Ptr           *uint32
	Float32             float32
	Float32Ptr          *float32
	Float32Alias        Float32Alias
	Float32AliasPtr     *Float32Alias
	Float64             float64
	Float64Ptr          *float64
	String              string
	StringPtr           *string
	StringAlias         StringAlias
	StringAliasPtr      *StringAlias
	Struct              struct{}
	StructPtr           *Inner
	SliceString         []string
	SliceStringAlias    SliceStringAlias
	SlicePtrString      []*string
	SliceStringPtrAlias SlicePtrStringAlias
	SliceStringPtr      *[]string
	SliceByte           []byte
}) (libjson.Value, error) {

	result := libjson.NewObject()

	// Byte byte
	{
		obj := &obj.Byte

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_byte((*byte)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Byte"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Byte was empty")
		} //FIXME:
	}

	// BytePtr *byte
	{
		obj := &obj.BytePtr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_byte((**byte)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "BytePtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: BytePtr was empty")
		} //FIXME:
	}

	// ByteAlias k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.ByteAlias
	{
		obj := &obj.ByteAlias

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_everything_ByteAlias((*ByteAlias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "ByteAlias"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: ByteAlias was empty")
		} //FIXME:
	}

	// ByteAliasPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.ByteAlias
	{
		obj := &obj.ByteAliasPtr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_everything_ByteAlias((**ByteAlias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "ByteAliasPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: ByteAliasPtr was empty")
		} //FIXME:
	}

	// Bool bool
	{
		obj := &obj.Bool

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_bool((*bool)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Bool"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Bool was empty")
		} //FIXME:
	}

	// BoolPtr *bool
	{
		obj := &obj.BoolPtr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_bool((**bool)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "BoolPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: BoolPtr was empty")
		} //FIXME:
	}

	// BoolAlias k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.BoolAlias
	{
		obj := &obj.BoolAlias

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_everything_BoolAlias((*BoolAlias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "BoolAlias"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: BoolAlias was empty")
		} //FIXME:
	}

	// BoolAliasPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.BoolAlias
	{
		obj := &obj.BoolAliasPtr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_everything_BoolAlias((**BoolAlias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "BoolAliasPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: BoolAliasPtr was empty")
		} //FIXME:
	}

	// Int8 int8
	{
		obj := &obj.Int8

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_int8((*int8)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Int8"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Int8 was empty")
		} //FIXME:
	}

	// Int8Ptr *int8
	{
		obj := &obj.Int8Ptr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_int8((**int8)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Int8Ptr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Int8Ptr was empty")
		} //FIXME:
	}

	// Int16 int16
	{
		obj := &obj.Int16

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_int16((*int16)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Int16"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Int16 was empty")
		} //FIXME:
	}

	// Int16Ptr *int16
	{
		obj := &obj.Int16Ptr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_int16((**int16)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Int16Ptr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Int16Ptr was empty")
		} //FIXME:
	}

	// Int32 int32
	{
		obj := &obj.Int32

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_int32((*int32)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Int32"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Int32 was empty")
		} //FIXME:
	}

	// Int32Ptr *int32
	{
		obj := &obj.Int32Ptr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_int32((**int32)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Int32Ptr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Int32Ptr was empty")
		} //FIXME:
	}

	// Int32Alias k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.Int32Alias
	{
		obj := &obj.Int32Alias

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_everything_Int32Alias((*Int32Alias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Int32Alias"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Int32Alias was empty")
		} //FIXME:
	}

	// Int32AliasPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.Int32Alias
	{
		obj := &obj.Int32AliasPtr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_everything_Int32Alias((**Int32Alias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Int32AliasPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Int32AliasPtr was empty")
		} //FIXME:
	}

	// Uint8 uint8
	{
		obj := &obj.Uint8

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_uint8((*uint8)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Uint8"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Uint8 was empty")
		} //FIXME:
	}

	// Uint8Ptr *uint8
	{
		obj := &obj.Uint8Ptr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_uint8((**uint8)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Uint8Ptr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Uint8Ptr was empty")
		} //FIXME:
	}

	// Uint16 uint16
	{
		obj := &obj.Uint16

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_uint16((*uint16)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Uint16"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Uint16 was empty")
		} //FIXME:
	}

	// Uint16Ptr *uint16
	{
		obj := &obj.Uint16Ptr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_uint16((**uint16)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Uint16Ptr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Uint16Ptr was empty")
		} //FIXME:
	}

	// Uint32 uint32
	{
		obj := &obj.Uint32

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_uint32((*uint32)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Uint32"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Uint32 was empty")
		} //FIXME:
	}

	// Uint32Ptr *uint32
	{
		obj := &obj.Uint32Ptr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_uint32((**uint32)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Uint32Ptr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Uint32Ptr was empty")
		} //FIXME:
	}

	// Float32 float32
	{
		obj := &obj.Float32

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_float32((*float32)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Float32"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Float32 was empty")
		} //FIXME:
	}

	// Float32Ptr *float32
	{
		obj := &obj.Float32Ptr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_float32((**float32)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Float32Ptr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Float32Ptr was empty")
		} //FIXME:
	}

	// Float32Alias k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.Float32Alias
	{
		obj := &obj.Float32Alias

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_everything_Float32Alias((*Float32Alias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Float32Alias"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Float32Alias was empty")
		} //FIXME:
	}

	// Float32AliasPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.Float32Alias
	{
		obj := &obj.Float32AliasPtr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_everything_Float32Alias((**Float32Alias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Float32AliasPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Float32AliasPtr was empty")
		} //FIXME:
	}

	// Float64 float64
	{
		obj := &obj.Float64

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_float64((*float64)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Float64"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Float64 was empty")
		} //FIXME:
	}

	// Float64Ptr *float64
	{
		obj := &obj.Float64Ptr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_float64((**float64)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Float64Ptr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Float64Ptr was empty")
		} //FIXME:
	}

	// String string
	{
		obj := &obj.String

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_string((*string)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "String"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: String was empty")
		} //FIXME:
	}

	// StringPtr *string
	{
		obj := &obj.StringPtr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_string((**string)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "StringPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: StringPtr was empty")
		} //FIXME:
	}

	// StringAlias k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.StringAlias
	{
		obj := &obj.StringAlias

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_everything_StringAlias((*StringAlias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "StringAlias"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: StringAlias was empty")
		} //FIXME:
	}

	// StringAliasPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.StringAlias
	{
		obj := &obj.StringAliasPtr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_everything_StringAlias((**StringAlias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "StringAliasPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: StringAliasPtr was empty")
		} //FIXME:
	}

	// Struct struct{}
	{
		obj := &obj.Struct

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Struct((*struct{})(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Struct"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Struct was empty")
		} //FIXME:
	}

	// StructPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.Inner
	{
		obj := &obj.StructPtr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_everything_Inner((**Inner)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "StructPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: StructPtr was empty")
		} //FIXME:
	}

	// SliceString []string
	{
		obj := &obj.SliceString

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Slice_string((*[]string)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "SliceString"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: SliceString was empty")
		} //FIXME:
	}

	// SliceStringAlias k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.SliceStringAlias
	{
		obj := &obj.SliceStringAlias

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_everything_SliceStringAlias((*SliceStringAlias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "SliceStringAlias"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: SliceStringAlias was empty")
		} //FIXME:
	}

	// SlicePtrString []*string
	{
		obj := &obj.SlicePtrString

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Slice_Pointer_string((*[]*string)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "SlicePtrString"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: SlicePtrString was empty")
		} //FIXME:
	}

	// SliceStringPtrAlias k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.SlicePtrStringAlias
	{
		obj := &obj.SliceStringPtrAlias

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_everything_SlicePtrStringAlias((*SlicePtrStringAlias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "SliceStringPtrAlias"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: SliceStringPtrAlias was empty")
		} //FIXME:
	}

	// SliceStringPtr *[]string
	{
		obj := &obj.SliceStringPtr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_Slice_string((**[]string)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "SliceStringPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: SliceStringPtr was empty")
		} //FIXME:
	}

	// SliceByte []byte
	{
		obj := &obj.SliceByte

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Slice_byte((*[]byte)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "SliceByte"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: SliceByte was empty")
		} //FIXME:
	}

	return result, nil

}

func ast_Pointer_Struct_Byte_byte_BytePtr_Pointer_byte_ByteAlias_everything_ByteAlias_ByteAliasPtr_Pointer_everything_ByteAlias_Bool_bool_BoolPtr_Pointer_bool_BoolAlias_everything_BoolAlias_BoolAliasPtr_Pointer_everything_BoolAlias_Int8_int8_Int8Ptr_Pointer_int8_Int16_int16_Int16Ptr_Pointer_int16_Int32_int32_Int32Ptr_Pointer_int32_Int32Alias_everything_Int32Alias_Int32AliasPtr_Pointer_everything_Int32Alias_Uint8_uint8_Uint8Ptr_Pointer_uint8_Uint16_uint16_Uint16Ptr_Pointer_uint16_Uint32_uint32_Uint32Ptr_Pointer_uint32_Float32_float32_Float32Ptr_Pointer_float32_Float32Alias_everything_Float32Alias_Float32AliasPtr_Pointer_everything_Float32Alias_Float64_float64_Float64Ptr_Pointer_float64_String_string_StringPtr_Pointer_string_StringAlias_everything_StringAlias_StringAliasPtr_Pointer_everything_StringAlias_Struct_Struct_StructPtr_Pointer_everything_Inner_SliceString_Slice_string_SliceStringAlias_everything_SliceStringAlias_SlicePtrString_Slice_Pointer_string_SliceStringPtrAlias_everything_SlicePtrStringAlias_SliceStringPtr_Pointer_Slice_string_SliceByte_Slice_byte_MapStringString_Map_string_To_string_MapStringStringPtr_Pointer_Map_string_To_string_MapStringStringAlias_everything_MapStringStringAlias_MapStringStringAliasPtr_Pointer_everything_MapStringStringAlias(obj **struct {
	Byte                    byte
	BytePtr                 *byte
	ByteAlias               ByteAlias
	ByteAliasPtr            *ByteAlias
	Bool                    bool
	BoolPtr                 *bool
	BoolAlias               BoolAlias
	BoolAliasPtr            *BoolAlias
	Int8                    int8
	Int8Ptr                 *int8
	Int16                   int16
	Int16Ptr                *int16
	Int32                   int32
	Int32Ptr                *int32
	Int32Alias              Int32Alias
	Int32AliasPtr           *Int32Alias
	Uint8                   uint8
	Uint8Ptr                *uint8
	Uint16                  uint16
	Uint16Ptr               *uint16
	Uint32                  uint32
	Uint32Ptr               *uint32
	Float32                 float32
	Float32Ptr              *float32
	Float32Alias            Float32Alias
	Float32AliasPtr         *Float32Alias
	Float64                 float64
	Float64Ptr              *float64
	String                  string
	StringPtr               *string
	StringAlias             StringAlias
	StringAliasPtr          *StringAlias
	Struct                  struct{}
	StructPtr               *Inner
	SliceString             []string
	SliceStringAlias        SliceStringAlias
	SlicePtrString          []*string
	SliceStringPtrAlias     SlicePtrStringAlias
	SliceStringPtr          *[]string
	SliceByte               []byte
	MapStringString         map[string]string
	MapStringStringPtr      *map[string]string
	MapStringStringAlias    MapStringStringAlias
	MapStringStringAliasPtr *MapStringStringAlias
}) (libjson.Value, error) {

	var jv libjson.Value
	var err error
	if *obj != nil {
		obj := *obj
		jv, err = ast_Struct_Byte_byte_BytePtr_Pointer_byte_ByteAlias_everything_ByteAlias_ByteAliasPtr_Pointer_everything_ByteAlias_Bool_bool_BoolPtr_Pointer_bool_BoolAlias_everything_BoolAlias_BoolAliasPtr_Pointer_everything_BoolAlias_Int8_int8_Int8Ptr_Pointer_int8_Int16_int16_Int16Ptr_Pointer_int16_Int32_int32_Int32Ptr_Pointer_int32_Int32Alias_everything_Int32Alias_Int32AliasPtr_Pointer_everything_Int32Alias_Uint8_uint8_Uint8Ptr_Pointer_uint8_Uint16_uint16_Uint16Ptr_Pointer_uint16_Uint32_uint32_Uint32Ptr_Pointer_uint32_Float32_float32_Float32Ptr_Pointer_float32_Float32Alias_everything_Float32Alias_Float32AliasPtr_Pointer_everything_Float32Alias_Float64_float64_Float64Ptr_Pointer_float64_String_string_StringPtr_Pointer_string_StringAlias_everything_StringAlias_StringAliasPtr_Pointer_everything_StringAlias_Struct_Struct_StructPtr_Pointer_everything_Inner_SliceString_Slice_string_SliceStringAlias_everything_SliceStringAlias_SlicePtrString_Slice_Pointer_string_SliceStringPtrAlias_everything_SlicePtrStringAlias_SliceStringPtr_Pointer_Slice_string_SliceByte_Slice_byte_MapStringString_Map_string_To_string_MapStringStringPtr_Pointer_Map_string_To_string_MapStringStringAlias_everything_MapStringStringAlias_MapStringStringAliasPtr_Pointer_everything_MapStringStringAlias((*struct {
			Byte                    byte
			BytePtr                 *byte
			ByteAlias               ByteAlias
			ByteAliasPtr            *ByteAlias
			Bool                    bool
			BoolPtr                 *bool
			BoolAlias               BoolAlias
			BoolAliasPtr            *BoolAlias
			Int8                    int8
			Int8Ptr                 *int8
			Int16                   int16
			Int16Ptr                *int16
			Int32                   int32
			Int32Ptr                *int32
			Int32Alias              Int32Alias
			Int32AliasPtr           *Int32Alias
			Uint8                   uint8
			Uint8Ptr                *uint8
			Uint16                  uint16
			Uint16Ptr               *uint16
			Uint32                  uint32
			Uint32Ptr               *uint32
			Float32                 float32
			Float32Ptr              *float32
			Float32Alias            Float32Alias
			Float32AliasPtr         *Float32Alias
			Float64                 float64
			Float64Ptr              *float64
			String                  string
			StringPtr               *string
			StringAlias             StringAlias
			StringAliasPtr          *StringAlias
			Struct                  struct{}
			StructPtr               *Inner
			SliceString             []string
			SliceStringAlias        SliceStringAlias
			SlicePtrString          []*string
			SliceStringPtrAlias     SlicePtrStringAlias
			SliceStringPtr          *[]string
			SliceByte               []byte
			MapStringString         map[string]string
			MapStringStringPtr      *map[string]string
			MapStringStringAlias    MapStringStringAlias
			MapStringStringAliasPtr *MapStringStringAlias
		})(obj))
		if err != nil {
			return nil, err
		}
	}
	setNull := func(b bool) (libjson.Value, error) {
		if b {
			*obj = nil
			return nil, nil
		}
		*obj = new(struct {
			Byte                    byte
			BytePtr                 *byte
			ByteAlias               ByteAlias
			ByteAliasPtr            *ByteAlias
			Bool                    bool
			BoolPtr                 *bool
			BoolAlias               BoolAlias
			BoolAliasPtr            *BoolAlias
			Int8                    int8
			Int8Ptr                 *int8
			Int16                   int16
			Int16Ptr                *int16
			Int32                   int32
			Int32Ptr                *int32
			Int32Alias              Int32Alias
			Int32AliasPtr           *Int32Alias
			Uint8                   uint8
			Uint8Ptr                *uint8
			Uint16                  uint16
			Uint16Ptr               *uint16
			Uint32                  uint32
			Uint32Ptr               *uint32
			Float32                 float32
			Float32Ptr              *float32
			Float32Alias            Float32Alias
			Float32AliasPtr         *Float32Alias
			Float64                 float64
			Float64Ptr              *float64
			String                  string
			StringPtr               *string
			StringAlias             StringAlias
			StringAliasPtr          *StringAlias
			Struct                  struct{}
			StructPtr               *Inner
			SliceString             []string
			SliceStringAlias        SliceStringAlias
			SlicePtrString          []*string
			SliceStringPtrAlias     SlicePtrStringAlias
			SliceStringPtr          *[]string
			SliceByte               []byte
			MapStringString         map[string]string
			MapStringStringPtr      *map[string]string
			MapStringStringAlias    MapStringStringAlias
			MapStringStringAliasPtr *MapStringStringAlias
		})
		obj := *obj
		return ast_Struct_Byte_byte_BytePtr_Pointer_byte_ByteAlias_everything_ByteAlias_ByteAliasPtr_Pointer_everything_ByteAlias_Bool_bool_BoolPtr_Pointer_bool_BoolAlias_everything_BoolAlias_BoolAliasPtr_Pointer_everything_BoolAlias_Int8_int8_Int8Ptr_Pointer_int8_Int16_int16_Int16Ptr_Pointer_int16_Int32_int32_Int32Ptr_Pointer_int32_Int32Alias_everything_Int32Alias_Int32AliasPtr_Pointer_everything_Int32Alias_Uint8_uint8_Uint8Ptr_Pointer_uint8_Uint16_uint16_Uint16Ptr_Pointer_uint16_Uint32_uint32_Uint32Ptr_Pointer_uint32_Float32_float32_Float32Ptr_Pointer_float32_Float32Alias_everything_Float32Alias_Float32AliasPtr_Pointer_everything_Float32Alias_Float64_float64_Float64Ptr_Pointer_float64_String_string_StringPtr_Pointer_string_StringAlias_everything_StringAlias_StringAliasPtr_Pointer_everything_StringAlias_Struct_Struct_StructPtr_Pointer_everything_Inner_SliceString_Slice_string_SliceStringAlias_everything_SliceStringAlias_SlicePtrString_Slice_Pointer_string_SliceStringPtrAlias_everything_SlicePtrStringAlias_SliceStringPtr_Pointer_Slice_string_SliceByte_Slice_byte_MapStringString_Map_string_To_string_MapStringStringPtr_Pointer_Map_string_To_string_MapStringStringAlias_everything_MapStringStringAlias_MapStringStringAliasPtr_Pointer_everything_MapStringStringAlias((*struct {
			Byte                    byte
			BytePtr                 *byte
			ByteAlias               ByteAlias
			ByteAliasPtr            *ByteAlias
			Bool                    bool
			BoolPtr                 *bool
			BoolAlias               BoolAlias
			BoolAliasPtr            *BoolAlias
			Int8                    int8
			Int8Ptr                 *int8
			Int16                   int16
			Int16Ptr                *int16
			Int32                   int32
			Int32Ptr                *int32
			Int32Alias              Int32Alias
			Int32AliasPtr           *Int32Alias
			Uint8                   uint8
			Uint8Ptr                *uint8
			Uint16                  uint16
			Uint16Ptr               *uint16
			Uint32                  uint32
			Uint32Ptr               *uint32
			Float32                 float32
			Float32Ptr              *float32
			Float32Alias            Float32Alias
			Float32AliasPtr         *Float32Alias
			Float64                 float64
			Float64Ptr              *float64
			String                  string
			StringPtr               *string
			StringAlias             StringAlias
			StringAliasPtr          *StringAlias
			Struct                  struct{}
			StructPtr               *Inner
			SliceString             []string
			SliceStringAlias        SliceStringAlias
			SlicePtrString          []*string
			SliceStringPtrAlias     SlicePtrStringAlias
			SliceStringPtr          *[]string
			SliceByte               []byte
			MapStringString         map[string]string
			MapStringStringPtr      *map[string]string
			MapStringStringAlias    MapStringStringAlias
			MapStringStringAliasPtr *MapStringStringAlias
		})(obj))
	}
	return libjson.NewNullable(jv, setNull), nil

}

func ast_Slice_byte(obj *[]byte) (libjson.Value, error) {

	get := func() []byte {
		return *obj
	}
	set := func(bs []byte) {
		*obj = bs
	}

	var jv libjson.Value
	if *obj != nil {
		jv = libjson.NewBytes(get, set)
	}
	setNull := func(b bool) (libjson.Value, error) {
		if b {
			*obj = nil
			return nil, nil
		}
		*obj = []byte{}
		return libjson.NewBytes(get, set), nil
	}
	return libjson.NewNullable(jv, setNull), nil

}

func ast_Struct_Struct_Struct_String_string(obj *struct{ Struct struct{ String string } }) (libjson.Value, error) {

	result := libjson.NewObject()

	// Struct struct{String string}
	{
		obj := &obj.Struct

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Struct_String_string((*struct{ String string })(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Struct"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Struct was empty")
		} //FIXME:
	}

	return result, nil

}

func ast_Struct(obj *struct{}) (libjson.Value, error) {

	result := libjson.NewObject()
	_ = obj

	return result, nil

}

func ast_Struct_Byte_byte_BytePtr_Pointer_byte_ByteAlias_everything_ByteAlias_ByteAliasPtr_Pointer_everything_ByteAlias_Bool_bool_BoolPtr_Pointer_bool_BoolAlias_everything_BoolAlias_BoolAliasPtr_Pointer_everything_BoolAlias_Int8_int8_Int8Ptr_Pointer_int8_Int16_int16_Int16Ptr_Pointer_int16_Int32_int32_Int32Ptr_Pointer_int32_Int32Alias_everything_Int32Alias_Int32AliasPtr_Pointer_everything_Int32Alias_Uint8_uint8_Uint8Ptr_Pointer_uint8_Uint16_uint16_Uint16Ptr_Pointer_uint16_Uint32_uint32_Uint32Ptr_Pointer_uint32_Float32_float32_Float32Ptr_Pointer_float32_Float32Alias_everything_Float32Alias_Float32AliasPtr_Pointer_everything_Float32Alias_Float64_float64_Float64Ptr_Pointer_float64_String_string_StringPtr_Pointer_string_StringAlias_everything_StringAlias_StringAliasPtr_Pointer_everything_StringAlias_Struct_Struct_StructPtr_Pointer_everything_Inner_SliceString_Slice_string_SliceStringAlias_everything_SliceStringAlias_SlicePtrString_Slice_Pointer_string_SliceStringPtrAlias_everything_SlicePtrStringAlias_SliceStringPtr_Pointer_Slice_string_SliceByte_Slice_byte_MapStringString_Map_string_To_string_MapStringStringPtr_Pointer_Map_string_To_string_MapStringStringAlias_everything_MapStringStringAlias_MapStringStringAliasPtr_Pointer_everything_MapStringStringAlias(obj *struct {
	Byte                    byte
	BytePtr                 *byte
	ByteAlias               ByteAlias
	ByteAliasPtr            *ByteAlias
	Bool                    bool
	BoolPtr                 *bool
	BoolAlias               BoolAlias
	BoolAliasPtr            *BoolAlias
	Int8                    int8
	Int8Ptr                 *int8
	Int16                   int16
	Int16Ptr                *int16
	Int32                   int32
	Int32Ptr                *int32
	Int32Alias              Int32Alias
	Int32AliasPtr           *Int32Alias
	Uint8                   uint8
	Uint8Ptr                *uint8
	Uint16                  uint16
	Uint16Ptr               *uint16
	Uint32                  uint32
	Uint32Ptr               *uint32
	Float32                 float32
	Float32Ptr              *float32
	Float32Alias            Float32Alias
	Float32AliasPtr         *Float32Alias
	Float64                 float64
	Float64Ptr              *float64
	String                  string
	StringPtr               *string
	StringAlias             StringAlias
	StringAliasPtr          *StringAlias
	Struct                  struct{}
	StructPtr               *Inner
	SliceString             []string
	SliceStringAlias        SliceStringAlias
	SlicePtrString          []*string
	SliceStringPtrAlias     SlicePtrStringAlias
	SliceStringPtr          *[]string
	SliceByte               []byte
	MapStringString         map[string]string
	MapStringStringPtr      *map[string]string
	MapStringStringAlias    MapStringStringAlias
	MapStringStringAliasPtr *MapStringStringAlias
}) (libjson.Value, error) {

	result := libjson.NewObject()

	// Byte byte
	{
		obj := &obj.Byte

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_byte((*byte)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Byte"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Byte was empty")
		} //FIXME:
	}

	// BytePtr *byte
	{
		obj := &obj.BytePtr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_byte((**byte)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "BytePtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: BytePtr was empty")
		} //FIXME:
	}

	// ByteAlias k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.ByteAlias
	{
		obj := &obj.ByteAlias

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_everything_ByteAlias((*ByteAlias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "ByteAlias"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: ByteAlias was empty")
		} //FIXME:
	}

	// ByteAliasPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.ByteAlias
	{
		obj := &obj.ByteAliasPtr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_everything_ByteAlias((**ByteAlias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "ByteAliasPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: ByteAliasPtr was empty")
		} //FIXME:
	}

	// Bool bool
	{
		obj := &obj.Bool

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_bool((*bool)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Bool"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Bool was empty")
		} //FIXME:
	}

	// BoolPtr *bool
	{
		obj := &obj.BoolPtr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_bool((**bool)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "BoolPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: BoolPtr was empty")
		} //FIXME:
	}

	// BoolAlias k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.BoolAlias
	{
		obj := &obj.BoolAlias

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_everything_BoolAlias((*BoolAlias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "BoolAlias"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: BoolAlias was empty")
		} //FIXME:
	}

	// BoolAliasPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.BoolAlias
	{
		obj := &obj.BoolAliasPtr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_everything_BoolAlias((**BoolAlias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "BoolAliasPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: BoolAliasPtr was empty")
		} //FIXME:
	}

	// Int8 int8
	{
		obj := &obj.Int8

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_int8((*int8)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Int8"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Int8 was empty")
		} //FIXME:
	}

	// Int8Ptr *int8
	{
		obj := &obj.Int8Ptr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_int8((**int8)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Int8Ptr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Int8Ptr was empty")
		} //FIXME:
	}

	// Int16 int16
	{
		obj := &obj.Int16

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_int16((*int16)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Int16"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Int16 was empty")
		} //FIXME:
	}

	// Int16Ptr *int16
	{
		obj := &obj.Int16Ptr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_int16((**int16)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Int16Ptr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Int16Ptr was empty")
		} //FIXME:
	}

	// Int32 int32
	{
		obj := &obj.Int32

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_int32((*int32)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Int32"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Int32 was empty")
		} //FIXME:
	}

	// Int32Ptr *int32
	{
		obj := &obj.Int32Ptr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_int32((**int32)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Int32Ptr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Int32Ptr was empty")
		} //FIXME:
	}

	// Int32Alias k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.Int32Alias
	{
		obj := &obj.Int32Alias

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_everything_Int32Alias((*Int32Alias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Int32Alias"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Int32Alias was empty")
		} //FIXME:
	}

	// Int32AliasPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.Int32Alias
	{
		obj := &obj.Int32AliasPtr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_everything_Int32Alias((**Int32Alias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Int32AliasPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Int32AliasPtr was empty")
		} //FIXME:
	}

	// Uint8 uint8
	{
		obj := &obj.Uint8

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_uint8((*uint8)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Uint8"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Uint8 was empty")
		} //FIXME:
	}

	// Uint8Ptr *uint8
	{
		obj := &obj.Uint8Ptr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_uint8((**uint8)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Uint8Ptr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Uint8Ptr was empty")
		} //FIXME:
	}

	// Uint16 uint16
	{
		obj := &obj.Uint16

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_uint16((*uint16)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Uint16"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Uint16 was empty")
		} //FIXME:
	}

	// Uint16Ptr *uint16
	{
		obj := &obj.Uint16Ptr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_uint16((**uint16)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Uint16Ptr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Uint16Ptr was empty")
		} //FIXME:
	}

	// Uint32 uint32
	{
		obj := &obj.Uint32

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_uint32((*uint32)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Uint32"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Uint32 was empty")
		} //FIXME:
	}

	// Uint32Ptr *uint32
	{
		obj := &obj.Uint32Ptr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_uint32((**uint32)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Uint32Ptr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Uint32Ptr was empty")
		} //FIXME:
	}

	// Float32 float32
	{
		obj := &obj.Float32

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_float32((*float32)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Float32"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Float32 was empty")
		} //FIXME:
	}

	// Float32Ptr *float32
	{
		obj := &obj.Float32Ptr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_float32((**float32)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Float32Ptr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Float32Ptr was empty")
		} //FIXME:
	}

	// Float32Alias k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.Float32Alias
	{
		obj := &obj.Float32Alias

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_everything_Float32Alias((*Float32Alias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Float32Alias"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Float32Alias was empty")
		} //FIXME:
	}

	// Float32AliasPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.Float32Alias
	{
		obj := &obj.Float32AliasPtr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_everything_Float32Alias((**Float32Alias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Float32AliasPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Float32AliasPtr was empty")
		} //FIXME:
	}

	// Float64 float64
	{
		obj := &obj.Float64

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_float64((*float64)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Float64"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Float64 was empty")
		} //FIXME:
	}

	// Float64Ptr *float64
	{
		obj := &obj.Float64Ptr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_float64((**float64)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Float64Ptr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Float64Ptr was empty")
		} //FIXME:
	}

	// String string
	{
		obj := &obj.String

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_string((*string)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "String"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: String was empty")
		} //FIXME:
	}

	// StringPtr *string
	{
		obj := &obj.StringPtr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_string((**string)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "StringPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: StringPtr was empty")
		} //FIXME:
	}

	// StringAlias k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.StringAlias
	{
		obj := &obj.StringAlias

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_everything_StringAlias((*StringAlias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "StringAlias"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: StringAlias was empty")
		} //FIXME:
	}

	// StringAliasPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.StringAlias
	{
		obj := &obj.StringAliasPtr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_everything_StringAlias((**StringAlias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "StringAliasPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: StringAliasPtr was empty")
		} //FIXME:
	}

	// Struct struct{}
	{
		obj := &obj.Struct

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Struct((*struct{})(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "Struct"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: Struct was empty")
		} //FIXME:
	}

	// StructPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.Inner
	{
		obj := &obj.StructPtr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_everything_Inner((**Inner)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "StructPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: StructPtr was empty")
		} //FIXME:
	}

	// SliceString []string
	{
		obj := &obj.SliceString

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Slice_string((*[]string)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "SliceString"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: SliceString was empty")
		} //FIXME:
	}

	// SliceStringAlias k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.SliceStringAlias
	{
		obj := &obj.SliceStringAlias

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_everything_SliceStringAlias((*SliceStringAlias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "SliceStringAlias"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: SliceStringAlias was empty")
		} //FIXME:
	}

	// SlicePtrString []*string
	{
		obj := &obj.SlicePtrString

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Slice_Pointer_string((*[]*string)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "SlicePtrString"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: SlicePtrString was empty")
		} //FIXME:
	}

	// SliceStringPtrAlias k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.SlicePtrStringAlias
	{
		obj := &obj.SliceStringPtrAlias

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_everything_SlicePtrStringAlias((*SlicePtrStringAlias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "SliceStringPtrAlias"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: SliceStringPtrAlias was empty")
		} //FIXME:
	}

	// SliceStringPtr *[]string
	{
		obj := &obj.SliceStringPtr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_Slice_string((**[]string)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "SliceStringPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: SliceStringPtr was empty")
		} //FIXME:
	}

	// SliceByte []byte
	{
		obj := &obj.SliceByte

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Slice_byte((*[]byte)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "SliceByte"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: SliceByte was empty")
		} //FIXME:
	}

	// MapStringString map[string]string
	{
		obj := &obj.MapStringString

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Map_string_To_string((*map[string]string)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "MapStringString"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: MapStringString was empty")
		} //FIXME:
	}

	// MapStringStringPtr *map[string]string
	{
		obj := &obj.MapStringStringPtr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_Map_string_To_string((**map[string]string)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "MapStringStringPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: MapStringStringPtr was empty")
		} //FIXME:
	}

	// MapStringStringAlias k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.MapStringStringAlias
	{
		obj := &obj.MapStringStringAlias

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_everything_MapStringStringAlias((*MapStringStringAlias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "MapStringStringAlias"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: MapStringStringAlias was empty")
		} //FIXME:
	}

	// MapStringStringAliasPtr *k8s.io/gengo/examples/json-gen/./output_tests/structs/everything.MapStringStringAlias
	{
		obj := &obj.MapStringStringAliasPtr

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_Pointer_everything_MapStringStringAlias((**MapStringStringAlias)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "MapStringStringAliasPtr"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: MapStringStringAliasPtr was empty")
		} //FIXME:
	}

	return result, nil

}

func ast_Struct_String_string(obj *struct{ String string }) (libjson.Value, error) {

	result := libjson.NewObject()

	// String string
	{
		obj := &obj.String

		empty := func(libjson.Value) bool { return false }

		finalize := func(jv libjson.Value) (libjson.Value, error) { return jv, nil }

		jv, err := ast_string((*string)(obj))
		if err != nil {
			return nil, err
		}
		if !empty(jv) {
			fv, err := finalize(jv)
			if err != nil {
				return nil, err
			}
			p := new(string)
			*p = "String"
			nv := libjson.NamedValue{
				Name:  libjson.NewString(func() string { return *p }, func(s string) { *p = s }),
				Value: fv,
			}
			result = append(result, nv)
		} else {
			panic("TIM: String was empty")
		} //FIXME:
	}

	return result, nil

}
