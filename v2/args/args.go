/*
Copyright 2015 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Package args has common command-line flags for generation programs.
package args

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	"k8s.io/gengo/v2/generator"
	"k8s.io/gengo/v2/namer"
	"k8s.io/gengo/v2/parser"

	"github.com/spf13/pflag"
)

// Default returns a defaulted GeneratorArgs. You may change the defaults
// before calling AddFlags.
func Default() *GeneratorArgs {
	return &GeneratorArgs{}
}

// GeneratorArgs has arguments that are passed to generators.
type GeneratorArgs struct {
	// Any custom arguments go here
	CustomArgs interface{}
}

func (g *GeneratorArgs) AddFlags(fs *pflag.FlagSet) {
}

const StdBuildTag = "ignore_autogenerated"
const StdGeneratedBy = "// Code generated by GENERATOR_NAME. DO NOT EDIT."

// GoBoilerplate returns the Go file header:
// - an optional build tag (negative, set it to ignore generated code)
// - an optional boilerplate file
// - an optional "generated by" comment
func GoBoilerplate(headerFile, buildTag, generatedBy string) ([]byte, error) {
	buf := bytes.Buffer{}

	if buildTag != "" {
		buf.WriteString(
			fmt.Sprintf("//go:build !%s\n// +build !%s\n\n", buildTag, buildTag))
	}

	if headerFile != "" {
		b, err := os.ReadFile(headerFile)
		if err != nil {
			return nil, err
		}
		b = bytes.ReplaceAll(b, []byte("YEAR"), []byte(strconv.Itoa(time.Now().UTC().Year())))
		buf.Write(b)
		buf.WriteByte('\n')
	}

	if generatedBy != "" {
		generatorName := filepath.Base(os.Args[0])
		generatedByComment := strings.ReplaceAll(generatedBy, "GENERATOR_NAME", generatorName)
		buf.WriteString(fmt.Sprintf("%s\n\n", generatedByComment))
	}

	return buf.Bytes(), nil
}

// NewBuilder makes a new parser.Builder and populates it with the input
// directories.
func (g *GeneratorArgs) NewBuilder(buildTags []string, patterns []string) (*parser.Builder, error) {
	b := parser.New(buildTags)
	if err := b.LoadPackages(patterns...); err != nil {
		return nil, err
	}
	return b, nil
}

// Execute implements main().
// If you don't need any non-default behavior, use as:
// args.Default().Execute(...)
func (g *GeneratorArgs) Execute(nameSystems namer.NameSystems, defaultSystem string, getTargets func(*generator.Context, *GeneratorArgs) []generator.Target, buildTag string, patterns []string) error {
	var buildTags []string
	if buildTag != "" {
		buildTags = append(buildTags, buildTag)
	}
	b, err := g.NewBuilder(buildTags, patterns)
	if err != nil {
		return fmt.Errorf("failed making a parser: %v", err)
	}

	c, err := generator.NewContext(b, nameSystems, defaultSystem)
	if err != nil {
		return fmt.Errorf("failed making a context: %v", err)
	}

	targets := getTargets(c, g)
	if err := c.ExecuteTargets(targets); err != nil {
		return fmt.Errorf("failed executing generator: %v", err)
	}

	return nil
}
